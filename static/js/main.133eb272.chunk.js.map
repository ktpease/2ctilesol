{"version":3,"sources":["game/Tile.js","game/Game.js","App.js","reportWebVitals.js","index.js"],"names":["Tile","props","tileNum","parseInt","tile","isNaN","glyph","className","tileStatusClass","selected","hinted","tileColorClass","pointer","onClick","String","fromCodePoint","Game","state","useEmoji","boardWidth","boardHeight","seed","tiles","selectedTile","hintedTiles","showMatchingTiles","allowDeselect","this","checkEmojiMode","generateBoard","window","navigator","test","userAgent","setState","allValidTiles","id","char","chardupe","finalSeed","seedrandom","int32","seededRng","tileCharUsed","Array","keys","randValue","i","length","Math","floor","x","push","y","console","log","tileId","debug","path","checkValidPath","newTiles","slice","filter","t","firstTile","secondTile","boardWidthWithEdges","boardHeightWithEdges","paths","simplestPath","tileXdelta","tileYdelta","DEBUG_pathsEaten","segment","dir","pop","at","curSegment","lastTile","nextTile","newPath","tileMap","map","renderTile","_el","index","reverse","tileobj","includes","handleTileClick","renderHorizontalMap","renderVerticalMap","React","Component","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.133eb272.chunk.js","sourcesContent":["export default function Tile(props) {\r\n  // Number between 0-42, corresponding to the Mahjong Tiles Unicode block.\r\n  const tileNum = parseInt(props.tile, 10);\r\n\r\n  // Check if tile is valid.\r\n  if (isNaN(tileNum) || tileNum < 0 || tileNum >= 42)\r\n    return props.glyph ? (\r\n      <span className=\"game-tile-glyph game-tile-empty\">&#x1F02B;&#xFE0E;</span>\r\n    ) : (\r\n      <span className=\"game-tile-emoji game-tile-empty\">&#x1F02B;</span>\r\n    );\r\n\r\n  let tileStatusClass = \"\";\r\n\r\n  if (props.selected) tileStatusClass = \"game-tile-selected\";\r\n  else if (props.hinted) tileStatusClass = \"game-tile-hinted\";\r\n\r\n  if (props.glyph) {\r\n    // If the font uses the glyph variant, give them a colorized border.\r\n    let tileColorClass = \"\";\r\n\r\n    if ((tileNum >= 7 && tileNum <= 15) || tileNum === 4) {\r\n      tileColorClass = \"game-tile-glyph-red\";\r\n    } else if ((tileNum >= 16 && tileNum <= 24) || tileNum === 5) {\r\n      tileColorClass = \"game-tile-glyph-green\";\r\n    } else if ((tileNum >= 25 && tileNum <= 33) || tileNum === 6) {\r\n      tileColorClass = \"game-tile-glyph-blue\";\r\n    } else if (tileNum >= 34 && tileNum <= 37) {\r\n      tileColorClass = \"game-tile-glyph-flowers\";\r\n    } else if (tileNum >= 38 && tileNum <= 41) {\r\n      tileColorClass = \"game-tile-glyph-seasons\";\r\n    }\r\n\r\n    return (\r\n      <span\r\n        className={`game-tile-glyph ${tileColorClass} ${tileStatusClass} ${\r\n          props.pointer ? \"game-tile-pointer\" : \"\"\r\n        }`}\r\n        onClick={props.onClick}\r\n      >\r\n        {String.fromCodePoint(0x1f000 + tileNum)}&#xFE0E;\r\n      </span>\r\n    );\r\n  } else {\r\n    return (\r\n      <span\r\n        className={`game-tile-emoji ${tileStatusClass} ${\r\n          props.pointer ? \"game-tile-pointer\" : \"\"\r\n        }`}\r\n        onClick={props.onClick}\r\n      >\r\n        {String.fromCodePoint(0x1f000 + tileNum)}\r\n      </span>\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport seedrandom from \"seedrandom\";\r\n\r\nimport \"./Game.css\";\r\n\r\nimport Tile from \"./Tile.js\";\r\n\r\nclass Game extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      useEmoji: false,\r\n      boardWidth: 17,\r\n      boardHeight: 8,\r\n      seed: 1,\r\n      tiles: [],\r\n      selectedTile: null,\r\n      hintedTiles: [],\r\n      showMatchingTiles: true,\r\n      allowDeselect: true,\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.checkEmojiMode();\r\n    this.generateBoard(null);\r\n  }\r\n\r\n  checkEmojiMode() {\r\n    // Currently, all majong tiles are Non-RGI with the exception of Red Dragon,\r\n    // and the only system font that supports all of these tiles as emojis is the\r\n    // Segoe UI Emoji family, included in Windows 10+.\r\n    //\r\n    // It is unlikely that future Unicode Emoji specifications will support\r\n    // all tiles as RGI, and I'm unsure if other system font providers will\r\n    // support them. So for now, we'll just assume that only desktop Windows 10+\r\n    // can run the emoji mode.\r\n    //\r\n    // If any other system or custom font providers begin supporting this, just\r\n    // please make sure they're front-facing (looking at you, Noto Emoji).\r\n\r\n    // If we don't care that it breaks previous Windows versions, we can just\r\n    // use the is-windows package. But for compatibility, we'll just check the\r\n    // browser's user agent string.\r\n    //\r\n    // Conveniently, Windows 10 and up have double-digit version numbers!\r\n    if (\r\n      window.navigator &&\r\n      /Windows NT \\d{2}/.test(window.navigator.userAgent)\r\n    ) {\r\n      this.setState({ useEmoji: true });\r\n    }\r\n  }\r\n\r\n  generateBoard(seed) {\r\n    const tiles = [],\r\n      allValidTiles = [];\r\n\r\n    let id = 0,\r\n      char = -1,\r\n      chardupe = -1;\r\n\r\n    // Determine if we need to generate a random seed\r\n    // or use a pre-determined one from the seed argument.\r\n    // This will be used in both tile selection and board shuffling.\r\n    const finalSeed = isNaN(parseInt(seed, 10))\r\n      ? seedrandom().int32() >>> 0\r\n      : parseInt(seed, 10) >>> 0;\r\n\r\n    const seededRng = seedrandom(finalSeed);\r\n\r\n    // Generate which tiles are used. This is done by listing all\r\n    // possible tiles (without duplicates), then shuffling with\r\n    // a simple Fisher-Yates shuffle.\r\n    let tileCharUsed = [...Array(34).keys()],\r\n      randValue = 0;\r\n\r\n    for (let i = tileCharUsed.length - 1; i > 0; i--) {\r\n      randValue = Math.floor(seededRng() * (i + 1));\r\n\r\n      char = tileCharUsed[i];\r\n      tileCharUsed[i] = tileCharUsed[randValue];\r\n      tileCharUsed[randValue] = char;\r\n    }\r\n\r\n    // Top outer edge.\r\n    for (let x = 0; x < this.state.boardWidth + 2; x++)\r\n      id = tiles.push({ id: id, char: null });\r\n\r\n    // Generate the initial unshuffled layout of tiles.\r\n    for (let y = 0; y < this.state.boardHeight; y++) {\r\n      // Left outer edge.\r\n      id = tiles.push({ id: id, char: null });\r\n\r\n      for (let x = 0; x < this.state.boardWidth; x++) {\r\n        if ((chardupe = (chardupe + 1) % 4) === 0) {\r\n          char = (char + 1) % tileCharUsed.length;\r\n        }\r\n\r\n        allValidTiles.push(id);\r\n        id = tiles.push({ id: id, char: tileCharUsed[char] });\r\n      }\r\n\r\n      // Right outer edge.\r\n      id = tiles.push({ id: id, char: null });\r\n    }\r\n\r\n    // Bottom outer edge.\r\n    for (let x = 0; x < this.state.boardWidth + 2; x++)\r\n      id = tiles.push({ id: id, char: null });\r\n\r\n    // Shuffle the board using a simple Fisher-Yates shuffle.\r\n    for (let i = allValidTiles.length - 1; i > 0; i--) {\r\n      randValue = Math.floor(seededRng() * (i + 1));\r\n\r\n      char = tiles[allValidTiles[i]].char;\r\n      tiles[allValidTiles[i]].char = tiles[allValidTiles[randValue]].char;\r\n      tiles[allValidTiles[randValue]].char = char;\r\n    }\r\n\r\n    console.log(`Game board seed is ${finalSeed}`);\r\n\r\n    this.setState({\r\n      tiles: tiles,\r\n      seed: finalSeed,\r\n      selectedTile: null,\r\n      hintedTiles: [],\r\n    });\r\n  }\r\n\r\n  handleTileClick(tileId) {\r\n    // Clicking the same tile either de-selects the tile or does nothing.\r\n    if (this.state.selectedTile === tileId) {\r\n      if (this.state.allowDeselect === true) {\r\n        this.setState({ selectedTile: null, hintedTiles: [] });\r\n        console.debug(`Unclicked ${tileId}`);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    console.debug(`Clicked ${tileId}`);\r\n\r\n    // If selecting a second tile, check to make sure it matches the first,\r\n    // then check the pathing to see if it's valid, then clear valid matches.\r\n    if (\r\n      this.state.selectedTile !== null &&\r\n      this.state.tiles[tileId].char ===\r\n        this.state.tiles[this.state.selectedTile].char\r\n    ) {\r\n      const path = this.checkValidPath(tileId, this.state.selectedTile);\r\n\r\n      if (path !== null) {\r\n        console.debug(path);\r\n\r\n        const newTiles = this.state.tiles.slice();\r\n\r\n        newTiles[tileId].char = null;\r\n        newTiles[this.state.selectedTile].char = null;\r\n\r\n        this.setState({ tiles: newTiles, selectedTile: null, hintedTiles: [] });\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Update the hinting system, if it's enabled.\r\n    if (this.state.showMatchingTiles === true) {\r\n      const hintedTiles = this.state.tiles.filter(\r\n        (t) => t.char === this.state.tiles[tileId].char\r\n      );\r\n\r\n      this.setState({ hintedTiles: hintedTiles, selectedTile: tileId });\r\n      return;\r\n    }\r\n\r\n    this.setState({ selectedTile: tileId });\r\n  }\r\n\r\n  checkValidPath(firstTile, secondTile) {\r\n    if (firstTile === secondTile) return null;\r\n\r\n    const boardWidthWithEdges = this.state.boardWidth + 2,\r\n      boardHeightWithEdges = this.state.boardHeight + 2;\r\n\r\n    let paths = [],\r\n      simplestPath = null;\r\n\r\n    const tileXdelta =\r\n      (secondTile % boardWidthWithEdges) - (firstTile % boardWidthWithEdges);\r\n    const tileYdelta =\r\n      (secondTile -\r\n        (secondTile % boardWidthWithEdges) -\r\n        (firstTile - (firstTile % boardWidthWithEdges))) /\r\n      boardWidthWithEdges;\r\n\r\n    let DEBUG_pathsEaten = 0;\r\n    console.debug(`tile X delta: ${tileXdelta}`);\r\n    console.debug(`tile Y delta: ${tileYdelta}`);\r\n\r\n    // Do not check opposite direction if in the same row or column.\r\n\r\n    if (tileYdelta !== 0 || tileXdelta > 0) {\r\n      paths.push([{ segment: [firstTile], dir: \"R\" }]);\r\n    }\r\n\r\n    if (tileYdelta !== 0 || tileXdelta < 0) {\r\n      paths.push([{ segment: [firstTile], dir: \"L\" }]);\r\n    }\r\n\r\n    if (tileXdelta !== 0 || tileYdelta > 0) {\r\n      paths.push([{ segment: [firstTile], dir: \"D\" }]);\r\n    }\r\n\r\n    if (tileXdelta !== 0 || tileYdelta < 0) {\r\n      paths.push([{ segment: [firstTile], dir: \"U\" }]);\r\n    }\r\n\r\n    for (let i = 0; i < paths.length; i++) {\r\n      console.debug(paths[i]);\r\n    }\r\n\r\n    while (paths.length > 0) {\r\n      const path = paths.pop();\r\n      DEBUG_pathsEaten++;\r\n\r\n      console.debug(\r\n        `Checking path: ${path.at(-1).segment} | ${path.at(-1).dir} | length: ${\r\n          path.length\r\n        } | queue: ${paths.length}`\r\n      );\r\n\r\n      // If we already found a three-line path, we shouldn't look for more\r\n      // three-line paths.\r\n      if (simplestPath !== null && path.length === 3) {\r\n        console.debug(\"- Looking for less-line paths\");\r\n        continue;\r\n      }\r\n\r\n      const curSegment = path.at(-1);\r\n      const lastTile = curSegment.segment.at(-1);\r\n      let nextTile;\r\n\r\n      switch (curSegment.dir) {\r\n        case \"R\":\r\n          nextTile = this.state.tiles[lastTile + 1];\r\n\r\n          // We found the path, or a simpler one!\r\n          if (nextTile.id === secondTile) {\r\n            console.debug(\"- Found simplest path?\");\r\n            curSegment.segment.push(nextTile.id);\r\n\r\n            // If it is a one-line or two-line path, it's one of the\r\n            // absolute shortest paths. We're done!\r\n            if (path.length < 3) {\r\n              console.debug(\"-- It is!\");\r\n              console.debug(`${DEBUG_pathsEaten} PATHS EATEN`);\r\n              return path;\r\n            }\r\n\r\n            console.debug(\"-- Maybe?\");\r\n            simplestPath = path;\r\n            continue;\r\n          }\r\n\r\n          // Obstruction in the path. Skip.\r\n          if (nextTile.char !== null) {\r\n            console.debug(\"- Obstruction in path\");\r\n            continue;\r\n          }\r\n\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // On first and second segment, check U if second tile is above and\r\n          // check D if the second tile is below.\r\n          // On second segment, only check if on same column.\r\n          if (\r\n            path.length < 3 &&\r\n            !(\r\n              path.length === 2 &&\r\n              secondTile % boardWidthWithEdges !==\r\n                nextTile.id % boardWidthWithEdges\r\n            )\r\n          ) {\r\n            if (secondTile < nextTile.id) {\r\n              console.debug(\"- Add path U\");\r\n              const newPath = path.slice();\r\n              newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n              paths.push(newPath);\r\n            } else if (secondTile > nextTile.id) {\r\n              console.debug(\"- Add path D\");\r\n              const newPath = path.slice();\r\n              newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n              paths.push(newPath);\r\n            }\r\n          }\r\n\r\n          if (\r\n            (path.length === 2 &&\r\n              secondTile % boardWidthWithEdges <\r\n                nextTile.id % boardWidthWithEdges) ||\r\n            nextTile.id % boardWidthWithEdges === boardWidthWithEdges - 1\r\n          ) {\r\n            console.debug(\"- Do not proceed further, will miss\");\r\n            continue;\r\n          }\r\n\r\n          console.debug(\"- Continuing path\");\r\n          paths.push(path);\r\n          continue;\r\n        case \"L\":\r\n          nextTile = this.state.tiles[lastTile - 1];\r\n\r\n          // We found the path, or a simpler one!\r\n          if (nextTile.id === secondTile) {\r\n            console.debug(\"- Found simplest path\");\r\n            curSegment.segment.push(nextTile.id);\r\n\r\n            // If it is a one-line or two-line path, it's one of the\r\n            // absolute shortest paths. We're done!\r\n            if (path.length < 3) {\r\n              console.debug(\"-- It is!\");\r\n              console.debug(`${DEBUG_pathsEaten} PATHS EATEN`);\r\n              return path;\r\n            }\r\n\r\n            console.debug(\"-- Maybe?\");\r\n            simplestPath = path;\r\n            continue;\r\n          }\r\n\r\n          // Obstruction in the path. Skip.\r\n          if (nextTile.char !== null) {\r\n            console.debug(\"- Obstruction in path\");\r\n            continue;\r\n          }\r\n\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // On first and second segment, check U if second tile is above and\r\n          // check D if the second tile is below.\r\n          // On second segment, only check if on same column.\r\n          if (\r\n            path.length < 3 &&\r\n            !(\r\n              path.length === 2 &&\r\n              secondTile % boardWidthWithEdges !==\r\n                nextTile.id % boardWidthWithEdges\r\n            )\r\n          ) {\r\n            if (secondTile < nextTile.id) {\r\n              console.debug(\"- Add path U\");\r\n              const newPath = path.slice();\r\n              newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n              paths.push(newPath);\r\n            } else if (secondTile > nextTile.id) {\r\n              console.debug(\"- Add path D\");\r\n              const newPath = path.slice();\r\n              newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n              paths.push(newPath);\r\n            }\r\n          }\r\n\r\n          if (\r\n            (path.length === 2 &&\r\n              secondTile % boardWidthWithEdges >\r\n                nextTile.id % boardWidthWithEdges) ||\r\n            nextTile.id % boardWidthWithEdges === 0\r\n          ) {\r\n            console.debug(\"- Do not proceed further, will miss\");\r\n            continue;\r\n          }\r\n\r\n          console.debug(\"- Continuing path\");\r\n          paths.push(path);\r\n          continue;\r\n        case \"D\":\r\n          nextTile = this.state.tiles[lastTile + boardWidthWithEdges];\r\n\r\n          // We found the path, or a simpler one!\r\n          if (nextTile.id === secondTile) {\r\n            console.debug(\"- Found simplest path\");\r\n            curSegment.segment.push(nextTile.id);\r\n\r\n            // If it is a one-line or two-line path, it's one of the\r\n            // absolute shortest paths. We're done!\r\n            if (path.length < 3) {\r\n              console.debug(\"-- It is!\");\r\n              console.debug(`${DEBUG_pathsEaten} PATHS EATEN`);\r\n              return path;\r\n            }\r\n\r\n            console.debug(\"-- Maybe?\");\r\n            simplestPath = path;\r\n            continue;\r\n          }\r\n\r\n          // Obstruction in the path. Skip.\r\n          if (nextTile.char !== null) {\r\n            console.debug(\"- Obstruction in path\");\r\n            continue;\r\n          }\r\n\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // On first and second segment, check L if second tile is left and\r\n          // check R if the second tile is right.\r\n          // On second segment, only check if on same row.\r\n          if (\r\n            path.length < 3 &&\r\n            !(\r\n              path.length === 2 &&\r\n              secondTile - (secondTile % boardWidthWithEdges) !==\r\n                nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            )\r\n          ) {\r\n            if (\r\n              secondTile % boardWidthWithEdges <\r\n              nextTile.id % boardWidthWithEdges\r\n            ) {\r\n              console.debug(\"- Add path L\");\r\n              const newPath = path.slice();\r\n              newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n              paths.push(newPath);\r\n            } else if (\r\n              secondTile % boardWidthWithEdges >\r\n              nextTile.id % boardWidthWithEdges\r\n            ) {\r\n              console.debug(\"- Add path R\");\r\n              const newPath = path.slice();\r\n              newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n              paths.push(newPath);\r\n            }\r\n          }\r\n\r\n          if (\r\n            (path.length === 2 && secondTile < nextTile.id) ||\r\n            nextTile.id >= boardWidthWithEdges * (boardHeightWithEdges - 1)\r\n          ) {\r\n            console.debug(\"- Do not proceed further, will miss\");\r\n            continue;\r\n          }\r\n\r\n          console.debug(\"- Continuing path\");\r\n          paths.push(path);\r\n          continue;\r\n        case \"U\":\r\n          nextTile = this.state.tiles[lastTile - boardWidthWithEdges];\r\n\r\n          // We found the path, or a simpler one!\r\n          if (nextTile.id === secondTile) {\r\n            console.debug(\"- Found simplest path\");\r\n            curSegment.segment.push(nextTile.id);\r\n\r\n            // If it is a one-line or two-line path, it's one of the\r\n            // absolute shortest paths. We're done!\r\n            if (path.length < 3) {\r\n              console.debug(\"-- It is!\");\r\n              console.debug(`${DEBUG_pathsEaten} PATHS EATEN`);\r\n              return path;\r\n            }\r\n\r\n            console.debug(\"-- Maybe?\");\r\n            simplestPath = path;\r\n            continue;\r\n          }\r\n\r\n          // Obstruction in the path. Skip.\r\n          if (nextTile.char !== null) {\r\n            console.debug(\"- Obstruction in path\");\r\n            continue;\r\n          }\r\n\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // On first and second segment, check L if second tile is left and\r\n          // check R if the second tile is right.\r\n          // On second segment, only check if on same row.\r\n          if (\r\n            path.length < 3 &&\r\n            !(\r\n              path.length === 2 &&\r\n              secondTile - (secondTile % boardWidthWithEdges) !==\r\n                nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            )\r\n          ) {\r\n            if (\r\n              secondTile % boardWidthWithEdges <\r\n              nextTile.id % boardWidthWithEdges\r\n            ) {\r\n              console.debug(\"- Add path L\");\r\n              const newPath = path.slice();\r\n              newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n              paths.push(newPath);\r\n            } else if (\r\n              secondTile % boardWidthWithEdges >\r\n              nextTile.id % boardWidthWithEdges\r\n            ) {\r\n              console.debug(\"- Add path R\");\r\n              const newPath = path.slice();\r\n              newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n              paths.push(newPath);\r\n            }\r\n          }\r\n\r\n          if (\r\n            (path.length === 2 && secondTile > nextTile.id) ||\r\n            nextTile.id < boardWidthWithEdges\r\n          ) {\r\n            console.debug(\"- Do not proceed further, will miss\");\r\n            continue;\r\n          }\r\n\r\n          console.debug(\"- Continuing path\");\r\n          paths.push(path);\r\n          continue;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n\r\n    console.debug(`${DEBUG_pathsEaten} PATHS EATEN`);\r\n    return simplestPath;\r\n  }\r\n\r\n  renderHorizontalMap() {\r\n    const tileMap = [];\r\n\r\n    // Standard horizontal board. Used for landscape orientation.\r\n    for (let y = 0; y < this.state.boardHeight; y++) {\r\n      tileMap[y] = (\r\n        <div key={\"board-hori-row\" + y}>\r\n          {this.state.tiles\r\n            .slice(\r\n              (y + 1) * (this.state.boardWidth + 2) + 1,\r\n              (y + 2) * (this.state.boardWidth + 2) - 1\r\n            )\r\n            .map((i) => this.renderTile(i))}\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return tileMap;\r\n  }\r\n\r\n  renderVerticalMap() {\r\n    const tileMap = [];\r\n\r\n    // Rotated vertical board. Used for portrait orientation.\r\n    for (let x = 0; x < this.state.boardWidth; x++) {\r\n      tileMap[x] = (\r\n        <div key={\"board-vert-row\" + x}>\r\n          {this.state.tiles\r\n            .slice(\r\n              this.state.boardWidth + 2,\r\n              (this.state.boardWidth + 2) * (this.state.boardHeight + 1)\r\n            )\r\n            .filter(\r\n              (_el, index) => index % (this.state.boardWidth + 2) === x + 1\r\n            )\r\n            .reverse()\r\n            .map((i) => this.renderTile(i))}\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return tileMap;\r\n  }\r\n\r\n  renderTile(tileobj) {\r\n    return (\r\n      <Tile\r\n        tile={tileobj.char}\r\n        key={tileobj.id}\r\n        glyph={!this.state.useEmoji}\r\n        selected={tileobj.id === this.state.selectedTile}\r\n        hinted={this.state.hintedTiles.includes(tileobj)}\r\n        onClick={() => this.handleTileClick(tileobj.id)}\r\n      />\r\n    );\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        <div>\r\n          <div\r\n            className={`game-board game-board-horizontal ${\r\n              this.state.useEmoji ? \"game-board-emoji\" : \"game-board-glyph\"\r\n            }`}\r\n          >\r\n            {this.renderHorizontalMap()}\r\n          </div>\r\n          <div\r\n            className={`game-board game-board-vertical ${\r\n              this.state.useEmoji ? \"game-board-emoji\" : \"game-board-glyph\"\r\n            }`}\r\n          >\r\n            {this.renderVerticalMap()}\r\n          </div>\r\n          <div>\r\n            <button\r\n              onClick={() =>\r\n                this.setState((state) => ({ useEmoji: !state.useEmoji }))\r\n              }\r\n            >\r\n              Change tile type\r\n            </button>\r\n            <button onClick={() => this.generateBoard()}>New board</button>\r\n            <button onClick={() => this.generateBoard(this.state.seed)}>\r\n              Reset board\r\n            </button>\r\n          </div>\r\n          <div>Board #{this.state.seed}</div>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Game;\r\n","import './App.css';\n\nimport Game from './game/Game.js'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Game/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}