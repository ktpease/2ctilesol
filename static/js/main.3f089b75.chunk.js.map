{"version":3,"sources":["game/Tile.js","game/PathNode.js","game/GameTimer.js","game/Game.js","game/BoardGenerator.js","game/PathLogic.js","App.js","reportWebVitals.js","index.js"],"names":["Tile","props","tileNum","parseInt","tile","isNaN","glyph","className","tileStatusClass","selected","hinted","highlighted","tileColorClass","pointer","fade","onClick","String","fromCodePoint","PathNode","node","length","nodeClass","forEach","dir","index","concat","GameTimer","React","forwardRef","ref","useStopwatch","autoStart","seconds","minutes","hours","start","pause","reset","useImperativeHandle","style","textAlign","toString","padStart","ReactModal","setAppElement","document","getElementById","Game","state","showSettingsModal","useEmoji","allowDeselect","showMatchingTiles","showAllValidMatches","boardWidth","boardHeight","seed","tiles","selectedTile","tileHistory","hintedTiles","allValidMatchingTiles","pathingTiles","pathingTilesAlt","useAltPathingTiles","horizontalTileMap","verticalTileMap","timerRef","createRef","this","checkEmojiMode","resetBoard","navigator","userAgentData","getHighEntropyValues","then","ua","platform","platformVersion","setState","window","test","userAgent","width","height","shuffleType","generatedBoard","newWidth","newHeight","allValidTiles","id","char","chardupe","randValue","finalSeed","seedrandom","int32","seededRng","usedTiles","Array","keys","brands","some","item","brand","mobile","includes","i","Math","floor","x","push","inRemovalAnim","y","generateBoardWithSimpleShuffle","allTiles","numOfPairs","tilePairOrder","sort","a","b","shuffledTilePairs","slice","map","edgeTiles","tileValue","filter","possibleMatches","board","boardWidthWithEdges","boardHeightWithEdges","validMatchingTiles","uncheckedMatchingTiles","checkRangeX","checkRangeY","paths","segment","path","pop","curSegment","at","lastTile","nextTile","lines","splice","indexOf","newPath","getMatchingEdgeTilesInPresolvedShuffle","undefined","console","warn","possibleMatchesMultiLine","matchingTile","generateBoardWithPresolvedShuffle","allValidMatches","generateHorizontalMap","generateVerticalMap","checkAllValidMatches","current","validMatches","checkAllPossibleMatches","Set","flat","tileId","firstTile","secondTile","simplestPath","tileXdelta","tileYdelta","unshift","checkSimplestPath","newTiles","tile1","tile2","line","prevState","t","lastMatch","tileMap","renderTileAndPath","_el","reverse","tileobj","boardprefix","handleTileClick","renderHorizontalMap","renderVerticalMap","undoMatch","disabled","isOpen","contentLabel","onRequestClose","hideSettingsModal","shouldCloseOnOverlayClick","Component","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.3f089b75.chunk.js","sourcesContent":["export default function Tile(props) {\r\n  // Number between 0-42, corresponding to the Mahjong Tiles Unicode block.\r\n  const tileNum = parseInt(props.tile, 10);\r\n\r\n  // Check if tile is valid.\r\n  if (isNaN(tileNum) || tileNum < 0 || tileNum >= 43) {\r\n    return props.glyph ? (\r\n      <span className=\"game-tile-glyph game-tile-empty\">&#x1F02B;&#xFE0E;</span>\r\n    ) : (\r\n      <span className=\"game-tile-emoji game-tile-empty\">&#x1F02B;</span>\r\n    );\r\n  }\r\n\r\n  let tileStatusClass = \"\";\r\n\r\n  if (props.selected) tileStatusClass = \"game-tile-selected\";\r\n  else if (props.hinted) tileStatusClass = \"game-tile-hinted\";\r\n  else if (props.highlighted) tileStatusClass = \"game-tile-highlighted\";\r\n\r\n  if (props.glyph) {\r\n    // If the font uses the glyph variant, give them a colorized border.\r\n    let tileColorClass = \"\";\r\n\r\n    if ((tileNum >= 7 && tileNum <= 15) || tileNum === 4) {\r\n      tileColorClass = \"game-tile-glyph-red\";\r\n    } else if ((tileNum >= 16 && tileNum <= 24) || tileNum === 5) {\r\n      tileColorClass = \"game-tile-glyph-green\";\r\n    } else if ((tileNum >= 25 && tileNum <= 33) || tileNum === 6) {\r\n      tileColorClass = \"game-tile-glyph-blue\";\r\n    } else if (tileNum >= 34 && tileNum <= 37) {\r\n      tileColorClass = \"game-tile-glyph-flowers\";\r\n    } else if (tileNum >= 38 && tileNum <= 41) {\r\n      tileColorClass = \"game-tile-glyph-seasons\";\r\n    }\r\n\r\n    return (\r\n      <span\r\n        className={`game-tile-glyph ${tileColorClass} ${tileStatusClass} ${\r\n          props.pointer ? \"game-tile-pointer\" : \"\"\r\n        } ${props.fade ? \"game-tile-anim-fadeout\" : \"\"}`}\r\n        onClick={props.onClick}\r\n      >\r\n        {String.fromCodePoint(0x1f000 + tileNum)}&#xFE0E;\r\n      </span>\r\n    );\r\n  } else {\r\n    return (\r\n      <span\r\n        className={`game-tile-emoji ${tileStatusClass} ${\r\n          props.pointer ? \"game-tile-pointer\" : \"\"\r\n        } ${props.fade ? \"game-tile-anim-fadeout\" : \"\"}`}\r\n        onClick={props.onClick}\r\n      >\r\n        {String.fromCodePoint(0x1f000 + tileNum)}\r\n      </span>\r\n    );\r\n  }\r\n}\r\n","export default function PathNode(props) {\r\n  if (props.node && props.node.length > 0) {\r\n    let nodeClass = \"\";\r\n\r\n    props.node.forEach((dir, index) => {\r\n      if (index === 0) nodeClass = \"game-path-\";\r\n      nodeClass = nodeClass.concat(dir);\r\n    });\r\n\r\n    return <span className={`game-path ${nodeClass} game-path-anim-fadeout`} />;\r\n  }\r\n\r\n  return null;\r\n}\r\n","import React from \"react\";\r\nimport { useStopwatch } from \"react-timer-hook\";\r\n\r\nconst GameTimer = React.forwardRef((props, ref) => {\r\n  const { seconds, minutes, hours, start, pause, reset } = useStopwatch({\r\n    autoStart: true,\r\n  });\r\n\r\n  React.useImperativeHandle(ref, () => ({\r\n    start,\r\n    pause,\r\n    reset,\r\n  }));\r\n\r\n  return (\r\n    <span style={{ textAlign: \"center\" }}>\r\n      {hours.toString().padStart(2, \"0\")}:{minutes.toString().padStart(2, \"0\")}:\r\n      {seconds.toString().padStart(2, \"0\")}\r\n    </span>\r\n  );\r\n});\r\n\r\nexport default GameTimer;\r\n","import React from \"react\";\r\nimport ReactModal from \"react-modal\";\r\n\r\nimport { checkSimplestPath, checkAllPossibleMatches } from \"./PathLogic.js\";\r\nimport {\r\n  generateBoardWithSimpleShuffle,\r\n  generateBoardWithPresolvedShuffle,\r\n} from \"./BoardGenerator.js\";\r\n\r\nimport Tile from \"./Tile.js\";\r\nimport PathNode from \"./PathNode.js\";\r\nimport GameTimer from \"./GameTimer.js\";\r\n\r\nimport \"./Game.css\";\r\nimport \"./SettingsModal.css\";\r\nimport \"./GameBar.css\";\r\n\r\nReactModal.setAppElement(document.getElementById(\"root\"));\r\n\r\nexport default class Game extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      // Settings\r\n      showSettingsModal: false,\r\n      useEmoji: false,\r\n      allowDeselect: true,\r\n      showMatchingTiles: false,\r\n      showAllValidMatches: false,\r\n      // Board Generation Options\r\n      boardWidth: 17,\r\n      boardHeight: 8,\r\n      seed: 1,\r\n      // Tile State\r\n      tiles: [],\r\n      selectedTile: null,\r\n      // Tile History\r\n      tileHistory: [],\r\n      // Tile Hinting\r\n      hintedTiles: [],\r\n      allValidMatchingTiles: [],\r\n      // Pathing Maps\r\n      pathingTiles: [],\r\n      pathingTilesAlt: [],\r\n      useAltPathingTiles: false,\r\n      // Tile Display Maps\r\n      horizontalTileMap: [],\r\n      verticalTileMap: [],\r\n    };\r\n\r\n    this.timerRef = React.createRef();\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.checkEmojiMode();\r\n    this.resetBoard();\r\n  }\r\n\r\n  checkEmojiMode() {\r\n    // Currently, all majong tiles are Non-RGI with the exception of Red Dragon,\r\n    // and the only system font that supports all of these tiles as emojis is the\r\n    // Segoe UI Emoji family, included in Windows 10+.\r\n    //\r\n    // It is unlikely that future Unicode Emoji specifications will support\r\n    // all tiles as RGI, and I'm unsure if other system font providers will\r\n    // support them. So for now, we'll just assume that only desktop Windows 10+\r\n    // can run the emoji mode.\r\n    //\r\n    // If any other system or custom font providers begin supporting this, just\r\n    // please make sure they're front-facing (looking at you, Noto Emoji).\r\n\r\n    // If we don't care that it breaks previous Windows versions, we can just\r\n    // use the is-windows package. But for compatibility, we'll just use the UA-CH\r\n    // API.\r\n    if (navigator.userAgentData)\r\n      navigator.userAgentData\r\n        .getHighEntropyValues([\"platform\", \"platformVersion\"])\r\n        .then((ua) => {\r\n          if (ua.platform === \"Windows\" && parseInt(ua.platformVersion) >= 10) {\r\n            console.log(\"Windows 10+ detected, using emoji tiles.\");\r\n            this.setState({ useEmoji: true });\r\n          }\r\n        });\r\n    else if (\r\n      window.navigator &&\r\n      /Windows NT \\d{2}/.test(window.navigator.userAgent)\r\n    ) {\r\n      console.log(\"Windows 10+ detected, using emoji tiles.\");\r\n      this.setState({ useEmoji: true });\r\n    }\r\n  }\r\n\r\n  resetBoard(seed, width, height, shuffleType) {\r\n    const newWidth = width ? width : this.state.boardWidth,\r\n      newHeight = height ? height : this.state.boardHeight;\r\n\r\n    let generatedBoard;\r\n\r\n    if (shuffleType && shuffleType === \"simple\") {\r\n      generatedBoard = generateBoardWithSimpleShuffle(\r\n        seed,\r\n        newWidth,\r\n        newHeight\r\n      );\r\n    } else {\r\n      generatedBoard = generateBoardWithPresolvedShuffle(\r\n        seed,\r\n        newWidth,\r\n        newHeight\r\n      );\r\n    }\r\n\r\n    this.setState(\r\n      {\r\n        tiles: generatedBoard.tiles,\r\n        boardWidth: newWidth,\r\n        boardHeight: newHeight,\r\n        seed: generatedBoard.seed,\r\n        selectedTile: null,\r\n        tileHistory: [],\r\n        hintedTiles: [],\r\n        allValidMatches: [],\r\n        pathingTiles: [],\r\n        pathingTilesAlt: [],\r\n        showSettingsModal: false,\r\n      },\r\n      () => {\r\n        this.generateHorizontalMap();\r\n        this.generateVerticalMap();\r\n\r\n        this.checkAllValidMatches();\r\n        this.timerRef.current.reset();\r\n      }\r\n    );\r\n  }\r\n\r\n  checkAllValidMatches() {\r\n    const allValidMatches = checkAllPossibleMatches(\r\n      this.state.tiles,\r\n      this.state.boardWidth,\r\n      this.state.boardHeight\r\n    );\r\n\r\n    console.log(\r\n      this.state.showAllValidMatches === true\r\n        ? \"Valid Matches: \" +\r\n            allValidMatches.reduce(\r\n              (a, b) =>\r\n                a.concat(\r\n                  `[${(b[0] % (this.state.boardWidth + 2)) - 1 + 1},${\r\n                    (b[0] -\r\n                      (b[0] % (this.state.boardWidth + 2)) -\r\n                      (this.state.boardWidth + 2)) /\r\n                      (this.state.boardWidth + 2) +\r\n                    1\r\n                  } <-> ${(b[1] % (this.state.boardWidth + 2)) - 1 + 1},${\r\n                    (b[1] -\r\n                      (b[1] % (this.state.boardWidth + 2)) -\r\n                      (this.state.boardWidth + 2)) /\r\n                      (this.state.boardWidth + 2) +\r\n                    1\r\n                  }] `\r\n                ),\r\n              \"\"\r\n            )\r\n        : \"\"\r\n    );\r\n\r\n    this.setState({\r\n      allValidMatchingTiles: [...new Set(allValidMatches.flat())],\r\n    });\r\n  }\r\n\r\n  handleTileClick(tileId) {\r\n    // Don't click empty or tiles being removed.\r\n    if (\r\n      this.state.tiles[tileId].char === null ||\r\n      this.state.tiles[tileId].inRemovalAnim === true\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // Clicking the same tile either de-selects the tile or does nothing.\r\n    if (this.state.selectedTile === tileId) {\r\n      if (this.state.allowDeselect === true) {\r\n        this.setState({ selectedTile: null, hintedTiles: [] });\r\n        console.debug(`Unclicked ${tileId}`);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    console.debug(`Clicked ${tileId}`);\r\n\r\n    // If selecting a second tile, check to make sure it matches the first,\r\n    // then check the pathing to see if it's valid, then clear valid matches.\r\n    if (\r\n      this.state.selectedTile !== null &&\r\n      this.state.tiles[tileId].char ===\r\n        this.state.tiles[this.state.selectedTile].char\r\n    ) {\r\n      const path = checkSimplestPath(\r\n        tileId,\r\n        this.state.selectedTile,\r\n        this.state.tiles.slice(),\r\n        this.state.boardWidth,\r\n        this.state.boardHeight\r\n      );\r\n\r\n      if (path !== null) {\r\n        console.debug(path);\r\n\r\n        // Create an updated board, first by removing the tiles in its\r\n        // fadeout animation, then putting the match in that same animation.\r\n        const newTiles = this.state.tiles.slice();\r\n\r\n        newTiles.forEach((tile) => {\r\n          if (tile.inRemovalAnim === true) {\r\n            tile.inRemovalAnim = false;\r\n            tile.char = null;\r\n          }\r\n        });\r\n\r\n        newTiles[tileId].inRemovalAnim = true;\r\n        newTiles[this.state.selectedTile].inRemovalAnim = true;\r\n\r\n        const tileHistory = this.state.tileHistory.slice();\r\n\r\n        tileHistory.push({\r\n          char: this.state.tiles[tileId].char,\r\n          tile1: tileId,\r\n          tile2: this.state.selectedTile,\r\n        });\r\n\r\n        // Generate the pathing tiles for display.\r\n        const pathingTiles = this.state.tiles.map(() => []);\r\n\r\n        path.forEach((line) => {\r\n          line.segment.forEach((node) => {\r\n            pathingTiles[node].push(line.dir);\r\n          });\r\n        });\r\n\r\n        pathingTiles[this.state.selectedTile].push(\"-start\");\r\n        pathingTiles[tileId].push(\"-end\");\r\n\r\n        this.setState(\r\n          {\r\n            tiles: newTiles,\r\n            selectedTile: null,\r\n            tileHistory: tileHistory,\r\n            hintedTiles: [],\r\n          },\r\n          () => {\r\n            this.checkAllValidMatches();\r\n          }\r\n        );\r\n\r\n        // Switch between primary and alternate pathing maps. This is used\r\n        // as a makeshift solution to consecutive matches using the same tile\r\n        // path, as the CSS animation doesn't get reset.\r\n        if (this.state.useAltPathingTiles === true)\r\n          this.setState((prevState) => ({\r\n            pathingTiles: prevState.tiles.map(() => []),\r\n            pathingTilesAlt: pathingTiles,\r\n            useAltPathingTiles: false,\r\n          }));\r\n        else\r\n          this.setState((prevState) => ({\r\n            pathingTiles: pathingTiles,\r\n            pathingTilesAlt: prevState.tiles.map(() => []),\r\n            useAltPathingTiles: true,\r\n          }));\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Update the hinting system, if it's enabled.\r\n    if (this.state.showMatchingTiles === true) {\r\n      const hintedTiles = this.state.tiles.filter(\r\n        (t) => t.char === this.state.tiles[tileId].char\r\n      );\r\n\r\n      this.setState({ hintedTiles: hintedTiles, selectedTile: tileId });\r\n      return;\r\n    }\r\n\r\n    this.setState({ selectedTile: tileId });\r\n  }\r\n\r\n  undoMatch() {\r\n    if (this.state.tileHistory.length > 0) {\r\n      const newTiles = this.state.tiles.slice();\r\n      const lastMatch = this.state.tileHistory.pop();\r\n\r\n      newTiles[lastMatch.tile1].char = lastMatch.char;\r\n      newTiles[lastMatch.tile1].inRemovalAnim = false;\r\n\r\n      newTiles[lastMatch.tile2].char = lastMatch.char;\r\n      newTiles[lastMatch.tile2].inRemovalAnim = false;\r\n\r\n      this.setState(\r\n        {\r\n          tiles: newTiles,\r\n          hintedTiles: [],\r\n          pathingTiles: [],\r\n          pathingTilesAlt: [],\r\n          selectedTile: null,\r\n        },\r\n        () => {\r\n          this.checkAllValidMatches();\r\n        }\r\n      );\r\n    }\r\n  }\r\n\r\n  showSettingsModal() {\r\n    this.timerRef.current.pause();\r\n\r\n    this.setState({ showSettingsModal: true });\r\n  }\r\n\r\n  hideSettingsModal() {\r\n    this.timerRef.current.start();\r\n\r\n    this.setState({ showSettingsModal: false });\r\n  }\r\n\r\n  generateHorizontalMap() {\r\n    const tileMap = [];\r\n\r\n    // Standard horizontal board. Used for landscape orientation.\r\n    for (let y = 0; y < this.state.boardHeight + 2; y++) {\r\n      tileMap[y] = this.state.tiles.slice(\r\n        y * (this.state.boardWidth + 2),\r\n        (y + 1) * (this.state.boardWidth + 2)\r\n      );\r\n    }\r\n\r\n    this.setState({ horizontalTileMap: tileMap });\r\n  }\r\n\r\n  renderHorizontalMap() {\r\n    const tileMap = [];\r\n\r\n    if (typeof this.state.horizontalTileMap === \"undefined\") {\r\n      return;\r\n    }\r\n\r\n    for (let y = 0; y < this.state.horizontalTileMap.length; y++) {\r\n      tileMap[y] = (\r\n        <div key={\"board-hori-row\" + y}>\r\n          {this.state.horizontalTileMap[y].map((i) =>\r\n            this.renderTileAndPath(i, \"hori\")\r\n          )}\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return tileMap;\r\n  }\r\n\r\n  generateVerticalMap() {\r\n    const tileMap = [];\r\n\r\n    // Rotated vertical board. Used for portrait orientation.\r\n    for (let x = 0; x < this.state.boardWidth + 2; x++) {\r\n      tileMap[x] = this.state.tiles\r\n        .filter((_el, index) => index % (this.state.boardWidth + 2) === x)\r\n        .reverse();\r\n    }\r\n\r\n    this.setState({ verticalTileMap: tileMap });\r\n  }\r\n\r\n  renderVerticalMap() {\r\n    const tileMap = [];\r\n\r\n    if (typeof this.state.verticalTileMap === \"undefined\") {\r\n      return;\r\n    }\r\n\r\n    for (let x = 0; x < this.state.verticalTileMap.length; x++) {\r\n      tileMap[x] = (\r\n        <div key={\"board-vert-row\" + x}>\r\n          {this.state.verticalTileMap[x].map((i) =>\r\n            this.renderTileAndPath(i, \"vert\")\r\n          )}\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return tileMap;\r\n  }\r\n\r\n  renderTileAndPath(tileobj, boardprefix) {\r\n    return (\r\n      <span key={tileobj.id}>\r\n        <Tile\r\n          tile={tileobj.char}\r\n          glyph={!this.state.useEmoji}\r\n          selected={tileobj.id === this.state.selectedTile}\r\n          hinted={\r\n            this.state.hintedTiles.includes(tileobj) && !tileobj.inRemovalAnim\r\n          }\r\n          highlighted={\r\n            this.state.showAllValidMatches &&\r\n            this.state.allValidMatchingTiles.includes(tileobj.id)\r\n          }\r\n          fade={tileobj.inRemovalAnim}\r\n          onClick={() => this.handleTileClick(tileobj.id)}\r\n        />\r\n        <PathNode node={this.state.pathingTiles[tileobj.id]} />\r\n        <PathNode node={this.state.pathingTilesAlt[tileobj.id]} />\r\n      </span>\r\n    );\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        <div>\r\n          <div\r\n            className={`game-board game-board-horizontal ${\r\n              this.state.useEmoji ? \"game-board-emoji\" : \"game-board-glyph\"\r\n            }`}\r\n          >\r\n            {this.renderHorizontalMap()}\r\n          </div>\r\n          <div\r\n            className={`game-board game-board-vertical ${\r\n              this.state.useEmoji ? \"game-board-emoji\" : \"game-board-glyph\"\r\n            }`}\r\n          >\r\n            {this.renderVerticalMap()}\r\n          </div>\r\n        </div>\r\n        <div className=\"game-bar\">\r\n          <GameTimer ref={this.timerRef} />\r\n          <button\r\n            className={`settings-button ${\r\n              this.state.showSettingsModal ? \"settings-button-opened\" : \"\"\r\n            }`}\r\n            onClick={() => this.showSettingsModal()}\r\n          >\r\n            &#8801;\r\n          </button>\r\n          <button\r\n            className=\"undo-button\"\r\n            onClick={() => this.undoMatch()}\r\n            disabled={this.state.tileHistory.length === 0}\r\n          >\r\n            &#11148;\r\n          </button>\r\n        </div>\r\n\r\n        <ReactModal\r\n          isOpen={this.state.showSettingsModal}\r\n          contentLabel=\"Settings\"\r\n          onRequestClose={() => this.hideSettingsModal()}\r\n          shouldCloseOnOverlayClick={false}\r\n        >\r\n          <div>\r\n            <div>Board #{this.state.seed}</div>\r\n            <button\r\n              onClick={() =>\r\n                this.setState((state) => ({ useEmoji: !state.useEmoji }))\r\n              }\r\n            >\r\n              Change tile type\r\n            </button>\r\n            <button onClick={() => this.resetBoard(this.state.seed)}>\r\n              Reset board\r\n            </button>\r\n            <button\r\n              onClick={() => this.undoMatch()}\r\n              disabled={this.state.tileHistory.length === 0}\r\n            >\r\n              Undo\r\n            </button>\r\n          </div>\r\n          <div>\r\n            Current number of tiles that can be matched:{\" \"}\r\n            {this.state.allValidMatchingTiles.length}\r\n          </div>\r\n          <div>\r\n            <button onClick={() => this.resetBoard(null, 8, 5)}>\r\n              New board (easy)\r\n            </button>\r\n            <button onClick={() => this.resetBoard(null, 12, 7)}>\r\n              New board (medium)\r\n            </button>\r\n            <button onClick={() => this.resetBoard(null, 17, 8)}>\r\n              New board (hard)\r\n            </button>\r\n          </div>\r\n          <div>\r\n            <button onClick={() => this.resetBoard(null, 8, 5, \"simple\")}>\r\n              New board (easy, pure random)\r\n            </button>\r\n            <button onClick={() => this.resetBoard(null, 12, 7, \"simple\")}>\r\n              New board (medium, pure random)\r\n            </button>\r\n            <button onClick={() => this.resetBoard(null, 17, 8, \"simple\")}>\r\n              New board (hard, pure random)\r\n            </button>\r\n          </div>\r\n          <div>\r\n            <button\r\n              onClick={() =>\r\n                this.setState((state) => ({\r\n                  showAllValidMatches: !state.showAllValidMatches,\r\n                }))\r\n              }\r\n            >\r\n              Toggle Highlight All Matches\r\n            </button>\r\n            <button\r\n              onClick={() =>\r\n                this.setState((state) => ({\r\n                  showMatchingTiles: !state.showMatchingTiles,\r\n                }))\r\n              }\r\n            >\r\n              Toggle Highlight Matching Tiles\r\n            </button>\r\n          </div>\r\n          <button onClick={() => this.hideSettingsModal()}>Close Modal</button>\r\n        </ReactModal>\r\n      </>\r\n    );\r\n  }\r\n}\r\n","import seedrandom from \"seedrandom\";\r\n\r\n// Generate a random game board by placing quadruplets of each random tile on\r\n// the board in the correct layout and then shuffling all tiles on the board\r\n// using a simple Fisher-Yates shuffle.\r\n//\r\n// Note: It'll generate a width+2 x height+2 board, with the edge row and\r\n// column being blank.\r\n//\r\n// This method is quicker and more random, but can generate an unwinnable board.\r\nexport function generateBoardWithSimpleShuffle(seed, width, height) {\r\n  const tiles = [],\r\n    allValidTiles = [];\r\n\r\n  let id = 0,\r\n    char = -1,\r\n    chardupe = -1,\r\n    randValue = 0;\r\n\r\n  // Determine if we need to generate a random seed\r\n  // or use a pre-determined one from the seed argument.\r\n  // This will be used in both tile selection and board shuffling.\r\n  const finalSeed = isNaN(parseInt(seed, 10))\r\n    ? seedrandom().int32() >>> 0\r\n    : parseInt(seed, 10) >>> 0;\r\n\r\n  const seededRng = seedrandom(finalSeed);\r\n\r\n  // Generate which tiles are used. This is done by listing all\r\n  // possible tiles (without duplicates), then shuffling it.\r\n  let usedTiles = [...Array(34).keys()];\r\n\r\n  // Chrome for Android has a bug where it'll not respect VS15/U+FE0E and\r\n  // always render the Red Dragon tile as emoji. Until it is fixed, replace\r\n  // the Red Dragon with the unused Joker tile.\r\n  if (\r\n    navigator.userAgentData\r\n      ? navigator.userAgentData.brands.some((item) => {\r\n          return item.brand === \"Chromium\";\r\n        }) === true && navigator.userAgentData.mobile === true\r\n      : window.navigator &&\r\n        window.navigator.userAgent.includes(\"Chrome\") &&\r\n        window.navigator.userAgent.includes(\"Mobile\")\r\n  ) {\r\n    usedTiles[4] = 42;\r\n  }\r\n\r\n  // Shuffle.\r\n  for (let i = usedTiles.length - 1; i > 0; i--) {\r\n    randValue = Math.floor(seededRng() * (i + 1));\r\n\r\n    char = usedTiles[i];\r\n    usedTiles[i] = usedTiles[randValue];\r\n    usedTiles[randValue] = char;\r\n  }\r\n\r\n  // Generate the initial unshuffled layout of tiles.\r\n  // Blank out the top outer edge.\r\n  for (let x = 0; x < width + 2; x++)\r\n    id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n\r\n  for (let y = 0; y < height; y++) {\r\n    // Blank out the left outer edge.\r\n    id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n\r\n    for (let x = 0; x < width; x++) {\r\n      if ((chardupe = (chardupe + 1) % 4) === 0) {\r\n        char = (char + 1) % usedTiles.length;\r\n      }\r\n\r\n      allValidTiles.push(id);\r\n      id = tiles.push({\r\n        id: id,\r\n        char: usedTiles[char],\r\n        inRemovalAnim: false,\r\n      });\r\n    }\r\n\r\n    // Blank out the right outer edge.\r\n    id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n  }\r\n\r\n  // Blank out the bottom outer edge.\r\n  for (let x = 0; x < width + 2; x++)\r\n    id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n\r\n  // Shuffle the board.\r\n  for (let i = allValidTiles.length - 1; i > 0; i--) {\r\n    randValue = Math.floor(seededRng() * (i + 1));\r\n\r\n    char = tiles[allValidTiles[i]].char;\r\n    tiles[allValidTiles[i]].char = tiles[allValidTiles[randValue]].char;\r\n    tiles[allValidTiles[randValue]].char = char;\r\n  }\r\n\r\n  console.log(\r\n    `Generated simple-shuffle ${width}x${height} board with seed ${finalSeed}`\r\n  );\r\n\r\n  return {\r\n    tiles: tiles,\r\n    seed: finalSeed,\r\n  };\r\n}\r\n\r\n// Generate a random game board by taking a complete layout of unknown tiles\r\n// and for each valid tile-match, in a random order, remove pairs from the\r\n// layout in a random formation.\r\n//\r\n// Note: It'll generate a width+2 x height+2 board, with the edge row and\r\n// column being blank.\r\n//\r\n// This method is slower, but genereates winnable boards.\r\nexport function generateBoardWithPresolvedShuffle(seed, width, height) {\r\n  const tiles = [];\r\n\r\n  let id = 0,\r\n    char = -1,\r\n    randValue = 0;\r\n\r\n  // Determine if we need to generate a random seed\r\n  // or use a pre-determined one from the seed argument.\r\n  // This will be used in both tile selection and board shuffling.\r\n  const finalSeed = isNaN(parseInt(seed, 10))\r\n    ? seedrandom().int32() >>> 0\r\n    : parseInt(seed, 10) >>> 0;\r\n\r\n  const seededRng = seedrandom(finalSeed);\r\n\r\n  // Generate the tile matching order for the solving algorithm. This is done\r\n  // by getting a list of valid tile pairs, then adjusting it to fit the\r\n  // layout, then shuffling it.\r\n  let allTiles = [...Array(34).keys()];\r\n\r\n  const numOfPairs = (width * height) >> 1;\r\n\r\n  // The value of each value in this array is a representation of a tile pair,\r\n  // based on its tile value. There are usually at least two pairs of a tile\r\n  // on a given board, so start with two pairs of all 34 tiles.\r\n  let tilePairOrder = allTiles.concat(allTiles).sort((a, b) => a - b);\r\n\r\n  // If the board is too big for the amount of pairs, we add more pairs in a\r\n  // random order.\r\n  while (tilePairOrder.length < numOfPairs) {\r\n    let shuffledTilePairs = allTiles.slice();\r\n\r\n    for (let i = shuffledTilePairs.length - 1; i > 0; i--) {\r\n      randValue = Math.floor(seededRng() * (i + 1));\r\n\r\n      char = shuffledTilePairs[i];\r\n      shuffledTilePairs[i] = shuffledTilePairs[randValue];\r\n      shuffledTilePairs[randValue] = char;\r\n    }\r\n\r\n    tilePairOrder = tilePairOrder.concat(shuffledTilePairs);\r\n  }\r\n\r\n  // Crop the number of pairs to fit the target total amount.\r\n  tilePairOrder = tilePairOrder.slice(0, numOfPairs);\r\n\r\n  // Chrome for Android has a bug where it'll not respect VS15/U+FE0E and\r\n  // always render the Red Dragon tile as emoji. Until it is fixed, replace\r\n  // the Red Dragon with the unused Joker tile.\r\n  if (\r\n    navigator.userAgentData\r\n      ? navigator.userAgentData.brands.some((item) => {\r\n          return item.brand === \"Chromium\";\r\n        }) === true && navigator.userAgentData.mobile === true\r\n      : window.navigator &&\r\n        window.navigator.userAgent.includes(\"Chrome\") &&\r\n        window.navigator.userAgent.includes(\"Mobile\")\r\n  ) {\r\n    tilePairOrder = tilePairOrder.map((x) => (x === 4 ? 42 : x));\r\n  }\r\n\r\n  // Shuffle.\r\n  for (let i = tilePairOrder.length - 1; i > 0; i--) {\r\n    randValue = Math.floor(seededRng() * (i + 1));\r\n\r\n    char = tilePairOrder[i];\r\n    tilePairOrder[i] = tilePairOrder[randValue];\r\n    tilePairOrder[randValue] = char;\r\n  }\r\n\r\n  // Generate the initial unshuffled layout of tiles.\r\n\r\n  // Blank out the top outer edge.\r\n  for (let x = 0; x < width + 2; x++)\r\n    id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n\r\n  for (let y = 0; y < height; y++) {\r\n    // Blank out the left outer edge.\r\n    id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n\r\n    for (let x = 0; x < width; x++) {\r\n      id = tiles.push({ id: id, char: -1, inRemovalAnim: false });\r\n    }\r\n\r\n    // Blank out the right outer edge.\r\n    id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n  }\r\n\r\n  // Blank out the bottom outer edge.\r\n  for (let x = 0; x < width + 2; x++)\r\n    id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n\r\n  let edgeTiles = [];\r\n\r\n  // Get all tiles with an empty edge.\r\n  for (let i = width + 2; i < tiles.length - (width + 2); i++) {\r\n    if (\r\n      tiles[i].char === -1 &&\r\n      (tiles[i - 1].char !== -1 ||\r\n        tiles[i + 1].char !== -1 ||\r\n        tiles[i - (width + 2)].char !== -1 ||\r\n        tiles[i + (width + 2)].char !== -1)\r\n    )\r\n      edgeTiles.push(i);\r\n  }\r\n\r\n  for (let i = 0; i < numOfPairs; i++) {\r\n    // Get a random unvisited edge tile.\r\n    let tileValue = edgeTiles[Math.floor(seededRng() * edgeTiles.length)];\r\n\r\n    // Add unvisited surrounding tiles to the open edge list.\r\n    if (\r\n      tiles[tileValue - 1].char === -1 &&\r\n      !edgeTiles.includes(tileValue - 1)\r\n    ) {\r\n      edgeTiles.push(tileValue - 1);\r\n    }\r\n    if (\r\n      tiles[tileValue + 1].char === -1 &&\r\n      !edgeTiles.includes(tileValue + 1)\r\n    ) {\r\n      edgeTiles.push(tileValue + 1);\r\n    }\r\n    if (\r\n      tiles[tileValue - (width + 2)].char === -1 &&\r\n      !edgeTiles.includes(tileValue - (width + 2))\r\n    ) {\r\n      edgeTiles.push(tileValue - (width + 2));\r\n    }\r\n    if (\r\n      tiles[tileValue + (width + 2)].char === -1 &&\r\n      !edgeTiles.includes(tileValue + (width + 2))\r\n    ) {\r\n      edgeTiles.push(tileValue + (width + 2));\r\n    }\r\n\r\n    // Don't match the tile with itself.\r\n    edgeTiles = edgeTiles.filter((x) => x !== tileValue);\r\n\r\n    let possibleMatches = getMatchingEdgeTilesInPresolvedShuffle(\r\n      tileValue,\r\n      tiles,\r\n      width,\r\n      height,\r\n      edgeTiles\r\n    );\r\n\r\n    if (possibleMatches === undefined || possibleMatches.length === 0) {\r\n      console.warn(\r\n        \"Presolve-shuffle detected an unmatching tile! This is bad.\"\r\n      );\r\n      continue;\r\n    }\r\n\r\n    // Prefer matches that use more than one line.\r\n    let possibleMatchesMultiLine = possibleMatches.filter((x) => x.lines > 1);\r\n\r\n    let matchingTile =\r\n      possibleMatchesMultiLine.length > 0\r\n        ? possibleMatchesMultiLine[\r\n            Math.floor(seededRng() * possibleMatchesMultiLine.length)\r\n          ].tile\r\n        : possibleMatches[Math.floor(seededRng() * possibleMatches.length)]\r\n            .tile;\r\n\r\n    // We found our pair!\r\n    tiles[tileValue].char = tilePairOrder[i];\r\n    tiles[matchingTile].char = tilePairOrder[i];\r\n\r\n    // Add unvisited surrounding tiles of the matched tile to the open edge list.\r\n    if (\r\n      tiles[matchingTile - 1].char === -1 &&\r\n      !edgeTiles.includes(matchingTile - 1)\r\n    ) {\r\n      edgeTiles.push(matchingTile - 1);\r\n    }\r\n    if (\r\n      tiles[matchingTile + 1].char === -1 &&\r\n      !edgeTiles.includes(matchingTile + 1)\r\n    ) {\r\n      edgeTiles.push(matchingTile + 1);\r\n    }\r\n    if (\r\n      tiles[matchingTile - (width + 2)].char === -1 &&\r\n      !edgeTiles.includes(matchingTile - (width + 2))\r\n    ) {\r\n      edgeTiles.push(matchingTile - (width + 2));\r\n    }\r\n    if (\r\n      tiles[matchingTile + (width + 2)].char === -1 &&\r\n      !edgeTiles.includes(matchingTile + (width + 2))\r\n    ) {\r\n      edgeTiles.push(matchingTile + (width + 2));\r\n    }\r\n\r\n    // Don't match future tile with the matched tile.\r\n    edgeTiles = edgeTiles.filter((x) => x !== matchingTile);\r\n  }\r\n\r\n  console.log(\r\n    `Generated presolved-shuffle ${width}x${height} board with seed ${finalSeed}`\r\n  );\r\n\r\n  return {\r\n    tiles: tiles,\r\n    seed: finalSeed,\r\n  };\r\n}\r\n\r\nfunction getMatchingEdgeTilesInPresolvedShuffle(\r\n  tile,\r\n  board,\r\n  boardWidth,\r\n  boardHeight,\r\n  edgeTiles\r\n) {\r\n  const boardWidthWithEdges = boardWidth + 2,\r\n    boardHeightWithEdges = boardHeight + 2;\r\n\r\n  let validMatchingTiles = [];\r\n\r\n  let uncheckedMatchingTiles = edgeTiles.slice();\r\n\r\n  // Get the X and Y ranges to check. This prevents the pathing algorithm\r\n  // from exploring areas it doesn't need to.\r\n  let checkRangeX = [],\r\n    checkRangeY = [];\r\n\r\n  uncheckedMatchingTiles.forEach((tile) => {\r\n    checkRangeX.push(tile % boardWidthWithEdges);\r\n    checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n  });\r\n\r\n  if (uncheckedMatchingTiles.length > 1) {\r\n    checkRangeX.sort((a, b) => a - b);\r\n    checkRangeY.sort((a, b) => a - b);\r\n  }\r\n\r\n  // Starting paths.\r\n  let paths = [];\r\n\r\n  paths.push([{ segment: [tile], dir: \"R\" }]);\r\n  paths.push([{ segment: [tile], dir: \"L\" }]);\r\n  paths.push([{ segment: [tile], dir: \"U\" }]);\r\n  paths.push([{ segment: [tile], dir: \"D\" }]);\r\n\r\n  while (paths.length > 0) {\r\n    const path = paths.pop();\r\n\r\n    const curSegment = path.at(-1);\r\n    const lastTile = curSegment.segment.at(-1);\r\n    let nextTile;\r\n\r\n    switch (curSegment.dir) {\r\n      case \"R\":\r\n        nextTile = board[lastTile + 1];\r\n\r\n        // Did we find a path?\r\n        if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n          validMatchingTiles.push({ tile: nextTile.id, lines: path.length });\r\n\r\n          uncheckedMatchingTiles.splice(\r\n            uncheckedMatchingTiles.indexOf(nextTile.id),\r\n            1\r\n          );\r\n\r\n          if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n          // Generate new ranges to check\r\n          uncheckedMatchingTiles.forEach((tile) => {\r\n            checkRangeX.push(tile % boardWidthWithEdges);\r\n            checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n          });\r\n\r\n          if (uncheckedMatchingTiles.length > 1) {\r\n            checkRangeX.sort((a, b) => a - b);\r\n            checkRangeY.sort((a, b) => a - b);\r\n          }\r\n\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char === -1) {\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // Branch out to different segments if necessary.\r\n        // On second segment, only check if on same column.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            !checkRangeX.includes(nextTile.id % boardWidthWithEdges)\r\n          )\r\n        ) {\r\n          if (\r\n            checkRangeY[0] <\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n            paths.push(newPath);\r\n          }\r\n\r\n          if (\r\n            checkRangeY.at(-1) >\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n            paths.push(newPath);\r\n          }\r\n        }\r\n\r\n        // Path is going too far away from the range or is nearing the edge\r\n        // of the board.\r\n        if (\r\n          (path.length === 2 &&\r\n            checkRangeX.at(-1) < nextTile.id % boardWidthWithEdges) ||\r\n          nextTile.id % boardWidthWithEdges === boardWidthWithEdges - 1\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        paths.push(path);\r\n        continue;\r\n      case \"L\":\r\n        nextTile = board[lastTile - 1];\r\n\r\n        // Did we find a path?\r\n        if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n          validMatchingTiles.push({ tile: nextTile.id, lines: path.length });\r\n\r\n          uncheckedMatchingTiles.splice(\r\n            uncheckedMatchingTiles.indexOf(nextTile.id),\r\n            1\r\n          );\r\n\r\n          if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n          // Generate new ranges to check\r\n          uncheckedMatchingTiles.forEach((tile) => {\r\n            checkRangeX.push(tile % boardWidthWithEdges);\r\n            checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n          });\r\n\r\n          if (uncheckedMatchingTiles.length > 1) {\r\n            checkRangeX.sort((a, b) => a - b);\r\n            checkRangeY.sort((a, b) => a - b);\r\n          }\r\n\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char === -1) {\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // Branch out to different segments if necessary.\r\n        // On second segment, only check if on same column.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            !checkRangeX.includes(nextTile.id % boardWidthWithEdges)\r\n          )\r\n        ) {\r\n          if (\r\n            checkRangeY[0] <\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n            paths.push(newPath);\r\n          }\r\n\r\n          if (\r\n            checkRangeY.at(-1) >\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n            paths.push(newPath);\r\n          }\r\n        }\r\n\r\n        // Path is going too far away from the range or is nearing the edge\r\n        // of the board.\r\n        if (\r\n          (path.length === 2 &&\r\n            checkRangeX[0] > nextTile.id % boardWidthWithEdges) ||\r\n          nextTile.id % boardWidthWithEdges === 0\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        paths.push(path);\r\n        continue;\r\n      case \"D\":\r\n        nextTile = board[lastTile + boardWidthWithEdges];\r\n\r\n        // Did we find a path?\r\n        if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n          validMatchingTiles.push({ tile: nextTile.id, lines: path.length });\r\n\r\n          uncheckedMatchingTiles.splice(\r\n            uncheckedMatchingTiles.indexOf(nextTile.id),\r\n            1\r\n          );\r\n\r\n          if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n          // Generate new ranges to check\r\n          uncheckedMatchingTiles.forEach((tile) => {\r\n            checkRangeX.push(tile % boardWidthWithEdges);\r\n            checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n          });\r\n\r\n          if (uncheckedMatchingTiles.length > 1) {\r\n            checkRangeX.sort((a, b) => a - b);\r\n            checkRangeY.sort((a, b) => a - b);\r\n          }\r\n\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char === -1) {\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // Branch out to different segments if necessary.\r\n        // On second segment, only check if on same row.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            !checkRangeY.includes(\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            )\r\n          )\r\n        ) {\r\n          if (checkRangeX[0] < nextTile.id % boardWidthWithEdges) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n            paths.push(newPath);\r\n          }\r\n\r\n          if (checkRangeX.at(-1) > nextTile.id % boardWidthWithEdges) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n            paths.push(newPath);\r\n          }\r\n        }\r\n\r\n        // Path is going too far away from the range or is nearing the edge\r\n        // of the board.\r\n        if (\r\n          (path.length === 2 &&\r\n            checkRangeY.at(-1) <\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)) ||\r\n          nextTile.id >= boardWidthWithEdges * (boardHeightWithEdges - 1)\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        paths.push(path);\r\n        continue;\r\n      case \"U\":\r\n        nextTile = board[lastTile - boardWidthWithEdges];\r\n\r\n        // Did we find a path?\r\n        if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n          validMatchingTiles.push({ tile: nextTile.id, lines: path.length });\r\n\r\n          uncheckedMatchingTiles.splice(\r\n            uncheckedMatchingTiles.indexOf(nextTile.id),\r\n            1\r\n          );\r\n\r\n          if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n          // Generate new ranges to check\r\n          uncheckedMatchingTiles.forEach((tile) => {\r\n            checkRangeX.push(tile % boardWidthWithEdges);\r\n            checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n          });\r\n\r\n          if (uncheckedMatchingTiles.length > 1) {\r\n            checkRangeX.sort((a, b) => a - b);\r\n            checkRangeY.sort((a, b) => a - b);\r\n          }\r\n\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char === -1) {\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // Branch out to different segments if necessary.\r\n        // On second segment, only check if on same row.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            !checkRangeY.includes(\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            )\r\n          )\r\n        ) {\r\n          if (checkRangeX[0] < nextTile.id % boardWidthWithEdges) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n            paths.push(newPath);\r\n          }\r\n\r\n          if (checkRangeX.at(-1) > nextTile.id % boardWidthWithEdges) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n            paths.push(newPath);\r\n          }\r\n        }\r\n\r\n        // Path is going too far away from the range or is nearing the edge\r\n        // of the board.\r\n        if (\r\n          (path.length === 2 &&\r\n            checkRangeY[0] >\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)) ||\r\n          nextTile.id < boardWidthWithEdges\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        paths.push(path);\r\n        continue;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  return validMatchingTiles;\r\n}\r\n","/**\r\n * Check the simplest (i.e. least amount of segments) nikakudori path between\r\n * two tiles on the provided game board.\r\n *\r\n * This utilizes an iterative depth-first search approach, with special modifications\r\n * to account for the limited amount of line segments.\r\n *\r\n * @param {!number} firstTile The tile index to start from\r\n * @param {!number} secondTile The tile index to end up on\r\n * @param {!{{<id: number, char: number>}}[]} board The tiles\r\n * themselves, which should be (1 + boardWidth + 1) * (1 + boardHeight + 1)\r\n * to account for the edges.\r\n * @param {!number} boardWidth Width of the board, excluding the edges.\r\n * @param {!number} boardHeight Height of the board, excluding the edges.\r\n * @returns {?{{<segment: number[], dir: string>}}[]} An array of line segments showing\r\n * one of the simplest paths. Segments are list of tile indexes in order.\r\n * Dir can be \"U\", \"D\", \"L\", or \"R\".\r\n */\r\nexport function checkSimplestPath(\r\n  firstTile,\r\n  secondTile,\r\n  board,\r\n  boardWidth,\r\n  boardHeight\r\n) {\r\n  if (firstTile === secondTile) return null;\r\n\r\n  const boardWidthWithEdges = boardWidth + 2,\r\n    boardHeightWithEdges = boardHeight + 2;\r\n\r\n  let paths = [],\r\n    simplestPath = null;\r\n\r\n  const tileXdelta =\r\n    (secondTile % boardWidthWithEdges) - (firstTile % boardWidthWithEdges);\r\n  const tileYdelta =\r\n    (secondTile -\r\n      (secondTile % boardWidthWithEdges) -\r\n      (firstTile - (firstTile % boardWidthWithEdges))) /\r\n    boardWidthWithEdges;\r\n\r\n  let DEBUG_pathsEaten = 0;\r\n  console.debug(`tile X delta: ${tileXdelta}`);\r\n  console.debug(`tile Y delta: ${tileYdelta}`);\r\n\r\n  // Do not check opposite direction if in the same row or column.\r\n\r\n  if (tileYdelta !== 0 || tileXdelta > 0) {\r\n    paths.push([{ segment: [firstTile], dir: \"R\" }]);\r\n  }\r\n\r\n  if (tileYdelta !== 0 || tileXdelta < 0) {\r\n    if (tileXdelta < 0) paths.push([{ segment: [firstTile], dir: \"L\" }]);\r\n    else paths.unshift([{ segment: [firstTile], dir: \"L\" }]);\r\n  }\r\n\r\n  if (tileXdelta !== 0 || tileYdelta > 0) {\r\n    if (tileYdelta >= 0) paths.push([{ segment: [firstTile], dir: \"D\" }]);\r\n    else paths.unshift([{ segment: [firstTile], dir: \"D\" }]);\r\n  }\r\n\r\n  if (tileXdelta !== 0 || tileYdelta < 0) {\r\n    if (tileYdelta < 0) paths.push([{ segment: [firstTile], dir: \"U\" }]);\r\n    else paths.push([{ segment: [firstTile], dir: \"U\" }]);\r\n  }\r\n\r\n  while (paths.length > 0) {\r\n    const path = paths.pop();\r\n    DEBUG_pathsEaten++;\r\n\r\n    console.debug(\r\n      `Checking path: ${path.at(-1).segment} | ${path.at(-1).dir} | length: ${\r\n        path.length\r\n      } | queue: ${paths.length}`\r\n    );\r\n\r\n    // If we already found a three-line path, we shouldn't look for more\r\n    // three-line paths.\r\n    if (simplestPath !== null && path.length === 3) {\r\n      console.debug(\"- Looking for less-line paths\");\r\n      continue;\r\n    }\r\n\r\n    const curSegment = path.at(-1);\r\n    const lastTile = curSegment.segment.at(-1);\r\n    let nextTile;\r\n\r\n    switch (curSegment.dir) {\r\n      case \"R\":\r\n        nextTile = board[lastTile + 1];\r\n\r\n        // We found the path, or a simpler one!\r\n        if (nextTile.id === secondTile) {\r\n          console.debug(\"- Found simplest path?\");\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // If it is a one-line or two-line path, it's one of the\r\n          // absolute shortest paths. We're done!\r\n          if (path.length < 3) {\r\n            console.debug(\"-- It is!\");\r\n            console.debug(`${DEBUG_pathsEaten} PATHS EATEN`);\r\n            return path;\r\n          }\r\n\r\n          console.debug(\"-- Maybe?\");\r\n          simplestPath = path;\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n          console.debug(\"- Obstruction in path\");\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // On first and second segment, check U if second tile is above and\r\n        // check D if the second tile is below.\r\n        // On second segment, only check if on same column.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            secondTile % boardWidthWithEdges !==\r\n              nextTile.id % boardWidthWithEdges\r\n          )\r\n        ) {\r\n          if (\r\n            secondTile - (secondTile % boardWidthWithEdges) <\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            console.debug(\"- Add path U\");\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n            if (tileYdelta < 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          } else if (\r\n            secondTile - (secondTile % boardWidthWithEdges) >\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            console.debug(\"- Add path D\");\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n            if (tileYdelta >= 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          }\r\n        }\r\n\r\n        if (\r\n          (path.length === 2 &&\r\n            secondTile % boardWidthWithEdges <\r\n              nextTile.id % boardWidthWithEdges) ||\r\n          nextTile.id % boardWidthWithEdges === boardWidthWithEdges - 1\r\n        ) {\r\n          console.debug(\"- Do not proceed further, will miss\");\r\n          continue;\r\n        }\r\n\r\n        console.debug(\"- Continuing path\");\r\n        if (tileXdelta >= 0) paths.push(path);\r\n        else paths.unshift(path);\r\n        continue;\r\n      case \"L\":\r\n        nextTile = board[lastTile - 1];\r\n\r\n        // We found the path, or a simpler one!\r\n        if (nextTile.id === secondTile) {\r\n          console.debug(\"- Found simplest path\");\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // If it is a one-line or two-line path, it's one of the\r\n          // absolute shortest paths. We're done!\r\n          if (path.length < 3) {\r\n            console.debug(\"-- It is!\");\r\n            console.debug(`${DEBUG_pathsEaten} PATHS EATEN`);\r\n            return path;\r\n          }\r\n\r\n          console.debug(\"-- Maybe?\");\r\n          simplestPath = path;\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n          console.debug(\"- Obstruction in path\");\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // On first and second segment, check U if second tile is above and\r\n        // check D if the second tile is below.\r\n        // On second segment, only check if on same column.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            secondTile % boardWidthWithEdges !==\r\n              nextTile.id % boardWidthWithEdges\r\n          )\r\n        ) {\r\n          if (\r\n            secondTile - (secondTile % boardWidthWithEdges) <\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            console.debug(\"- Add path U\");\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n            if (tileYdelta < 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          } else if (\r\n            secondTile - (secondTile % boardWidthWithEdges) >\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            console.debug(\"- Add path D\");\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n            if (tileYdelta >= 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          }\r\n        }\r\n\r\n        if (\r\n          (path.length === 2 &&\r\n            secondTile % boardWidthWithEdges >\r\n              nextTile.id % boardWidthWithEdges) ||\r\n          nextTile.id % boardWidthWithEdges === 0\r\n        ) {\r\n          console.debug(\"- Do not proceed further, will miss\");\r\n          continue;\r\n        }\r\n\r\n        console.debug(\"- Continuing path\");\r\n        if (tileXdelta < 0) paths.push(path);\r\n        else paths.unshift(path);\r\n        continue;\r\n      case \"D\":\r\n        nextTile = board[lastTile + boardWidthWithEdges];\r\n\r\n        // We found the path, or a simpler one!\r\n        if (nextTile.id === secondTile) {\r\n          console.debug(\"- Found simplest path\");\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // If it is a one-line or two-line path, it's one of the\r\n          // absolute shortest paths. We're done!\r\n          if (path.length < 3) {\r\n            console.debug(\"-- It is!\");\r\n            console.debug(`${DEBUG_pathsEaten} PATHS EATEN`);\r\n            return path;\r\n          }\r\n\r\n          console.debug(\"-- Maybe?\");\r\n          simplestPath = path;\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n          console.debug(\"- Obstruction in path\");\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // On first and second segment, check L if second tile is left and\r\n        // check R if the second tile is right.\r\n        // On second segment, only check if on same row.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            secondTile - (secondTile % boardWidthWithEdges) !==\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          )\r\n        ) {\r\n          if (\r\n            secondTile % boardWidthWithEdges <\r\n            nextTile.id % boardWidthWithEdges\r\n          ) {\r\n            console.debug(\"- Add path L\");\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n            if (tileXdelta < 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          } else if (\r\n            secondTile % boardWidthWithEdges >\r\n            nextTile.id % boardWidthWithEdges\r\n          ) {\r\n            console.debug(\"- Add path R\");\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n            if (tileXdelta >= 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          }\r\n        }\r\n\r\n        if (\r\n          (path.length === 2 &&\r\n            secondTile - (secondTile % boardWidthWithEdges) <\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)) ||\r\n          nextTile.id >= boardWidthWithEdges * (boardHeightWithEdges - 1)\r\n        ) {\r\n          console.debug(\"- Do not proceed further, will miss\");\r\n          continue;\r\n        }\r\n\r\n        console.debug(\"- Continuing path\");\r\n        if (tileYdelta >= 0) paths.push(path);\r\n        else paths.unshift(path);\r\n        continue;\r\n      case \"U\":\r\n        nextTile = board[lastTile - boardWidthWithEdges];\r\n\r\n        // We found the path, or a simpler one!\r\n        if (nextTile.id === secondTile) {\r\n          console.debug(\"- Found simplest path\");\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // If it is a one-line or two-line path, it's one of the\r\n          // absolute shortest paths. We're done!\r\n          if (path.length < 3) {\r\n            console.debug(\"-- It is!\");\r\n            console.debug(`${DEBUG_pathsEaten} PATHS EATEN`);\r\n            return path;\r\n          }\r\n\r\n          console.debug(\"-- Maybe?\");\r\n          simplestPath = path;\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n          console.debug(\"- Obstruction in path\");\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // On first and second segment, check L if second tile is left and\r\n        // check R if the second tile is right.\r\n        // On second segment, only check if on same row.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            secondTile - (secondTile % boardWidthWithEdges) !==\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          )\r\n        ) {\r\n          if (\r\n            secondTile % boardWidthWithEdges <\r\n            nextTile.id % boardWidthWithEdges\r\n          ) {\r\n            console.debug(\"- Add path L\");\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n            if (tileXdelta < 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          } else if (\r\n            secondTile % boardWidthWithEdges >\r\n            nextTile.id % boardWidthWithEdges\r\n          ) {\r\n            console.debug(\"- Add path R\");\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n            if (tileXdelta >= 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          }\r\n        }\r\n\r\n        if (\r\n          (path.length === 2 &&\r\n            secondTile - (secondTile % boardWidthWithEdges) >\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)) ||\r\n          nextTile.id < boardWidthWithEdges\r\n        ) {\r\n          console.debug(\"- Do not proceed further, will miss\");\r\n          continue;\r\n        }\r\n\r\n        console.debug(\"- Continuing path\");\r\n        if (tileYdelta < 0) paths.push(path);\r\n        else paths.unshift(path);\r\n        continue;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  console.debug(`${DEBUG_pathsEaten} PATHS EATEN`);\r\n  return simplestPath;\r\n}\r\n\r\n/**\r\n * Check all valid matches on the current game board.\r\n *\r\n * This utilizes an depth-first search approach, with special modifications\r\n * to account for the limited amount of line segments.\r\n *\r\n * @param {!{{<id: number, char: number>}}[]} board The tiles\r\n * themselves, which should be (1 + boardWidth + 1) * (1 + boardHeight + 1)\r\n * to account for the edges.\r\n * @param {!number} boardWidth Width of the board, excluding the edges.\r\n * @param {!number} boardHeight Height of the board, excluding the edges.\r\n * @returns {?number[][]} An array of valid matching tile ID pairs.\r\n */\r\nexport function checkAllPossibleMatches(board, boardWidth, boardHeight) {\r\n  const boardWidthWithEdges = boardWidth + 2,\r\n    boardHeightWithEdges = boardHeight + 2;\r\n\r\n  let validMatches = [];\r\n\r\n  console.debug(\r\n    `Checking all possible matches for a board with dimensions ${boardWidth} x ${boardHeight}`\r\n  );\r\n\r\n  // Throw out a path for each valid tile.\r\n  board.forEach((tile) => {\r\n    // Ignore missing tiles.\r\n    if (tile.char === null || tile.inRemovalAnim === true) return;\r\n\r\n    // Check each tile for matches against later tiles. We've already checked\r\n    // against earlier tiles in earlier checks.\r\n    let uncheckedMatchingTiles = [];\r\n\r\n    for (let i = tile.id + 1; i < board.length; i++) {\r\n      if (board[i].char === tile.char && board[i].inRemovalAnim === false) {\r\n        uncheckedMatchingTiles.push(i);\r\n      }\r\n    }\r\n\r\n    // No matches to check.\r\n    if (uncheckedMatchingTiles.length === 0) return;\r\n\r\n    console.debug(\r\n      `Checking tile ${tile.id} with tiles ${uncheckedMatchingTiles}`\r\n    );\r\n\r\n    // Get the X and Y ranges to check. This prevents the pathing algorithm\r\n    // from exploring areas it doesn't need to.\r\n    let checkRangeX = [],\r\n      checkRangeY = [];\r\n\r\n    uncheckedMatchingTiles.forEach((tile) => {\r\n      checkRangeX.push(tile % boardWidthWithEdges);\r\n      checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n    });\r\n\r\n    if (uncheckedMatchingTiles.length > 1) {\r\n      checkRangeX.sort((a, b) => a - b);\r\n      checkRangeY.sort((a, b) => a - b);\r\n    }\r\n\r\n    // Starting paths.\r\n    let paths = [];\r\n\r\n    paths.push([{ segment: [tile.id], dir: \"R\" }]);\r\n    paths.push([{ segment: [tile.id], dir: \"L\" }]);\r\n    paths.push([{ segment: [tile.id], dir: \"U\" }]);\r\n    paths.push([{ segment: [tile.id], dir: \"D\" }]);\r\n\r\n    while (paths.length > 0) {\r\n      const path = paths.pop();\r\n\r\n      const curSegment = path.at(-1);\r\n      const lastTile = curSegment.segment.at(-1);\r\n      let nextTile;\r\n\r\n      switch (curSegment.dir) {\r\n        case \"R\":\r\n          nextTile = board[lastTile + 1];\r\n\r\n          // Did we find a path?\r\n          if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n            validMatches.push([tile.id, nextTile.id]);\r\n\r\n            uncheckedMatchingTiles.splice(\r\n              uncheckedMatchingTiles.indexOf(nextTile.id),\r\n              1\r\n            );\r\n\r\n            if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n            // Generate new ranges to check\r\n            uncheckedMatchingTiles.forEach((tile) => {\r\n              checkRangeX.push(tile % boardWidthWithEdges);\r\n              checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n            });\r\n\r\n            if (uncheckedMatchingTiles.length > 1) {\r\n              checkRangeX.sort((a, b) => a - b);\r\n              checkRangeY.sort((a, b) => a - b);\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          // Obstruction in the path. Skip.\r\n          if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n            continue;\r\n          }\r\n\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // Branch out to different segments if necessary.\r\n          // On second segment, only check if on same column.\r\n          if (\r\n            path.length < 3 &&\r\n            !(\r\n              path.length === 2 &&\r\n              !checkRangeX.includes(nextTile.id % boardWidthWithEdges)\r\n            )\r\n          ) {\r\n            if (\r\n              checkRangeY[0] <\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            ) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n              paths.push(newPath);\r\n            }\r\n\r\n            if (\r\n              checkRangeY.at(-1) >\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            ) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n              paths.push(newPath);\r\n            }\r\n          }\r\n\r\n          // Path is going too far away from the range or is nearing the edge\r\n          // of the board.\r\n          if (\r\n            (path.length === 2 &&\r\n              checkRangeX.at(-1) < nextTile.id % boardWidthWithEdges) ||\r\n            nextTile.id % boardWidthWithEdges === boardWidthWithEdges - 1\r\n          ) {\r\n            continue;\r\n          }\r\n\r\n          paths.push(path);\r\n          continue;\r\n        case \"L\":\r\n          nextTile = board[lastTile - 1];\r\n\r\n          // Did we find a path?\r\n          if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n            validMatches.push([tile.id, nextTile.id]);\r\n\r\n            uncheckedMatchingTiles.splice(\r\n              uncheckedMatchingTiles.indexOf(nextTile.id),\r\n              1\r\n            );\r\n\r\n            if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n            // Generate new ranges to check\r\n            uncheckedMatchingTiles.forEach((tile) => {\r\n              checkRangeX.push(tile % boardWidthWithEdges);\r\n              checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n            });\r\n\r\n            if (uncheckedMatchingTiles.length > 1) {\r\n              checkRangeX.sort((a, b) => a - b);\r\n              checkRangeY.sort((a, b) => a - b);\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          // Obstruction in the path. Skip.\r\n          if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n            continue;\r\n          }\r\n\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // Branch out to different segments if necessary.\r\n          // On second segment, only check if on same column.\r\n          if (\r\n            path.length < 3 &&\r\n            !(\r\n              path.length === 2 &&\r\n              !checkRangeX.includes(nextTile.id % boardWidthWithEdges)\r\n            )\r\n          ) {\r\n            if (\r\n              checkRangeY[0] <\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            ) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n              paths.push(newPath);\r\n            }\r\n\r\n            if (\r\n              checkRangeY.at(-1) >\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            ) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n              paths.push(newPath);\r\n            }\r\n          }\r\n\r\n          // Path is going too far away from the range or is nearing the edge\r\n          // of the board.\r\n          if (\r\n            (path.length === 2 &&\r\n              checkRangeX[0] > nextTile.id % boardWidthWithEdges) ||\r\n            nextTile.id % boardWidthWithEdges === 0\r\n          ) {\r\n            continue;\r\n          }\r\n\r\n          paths.push(path);\r\n          continue;\r\n        case \"D\":\r\n          nextTile = board[lastTile + boardWidthWithEdges];\r\n\r\n          // Did we find a path?\r\n          if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n            validMatches.push([tile.id, nextTile.id]);\r\n\r\n            uncheckedMatchingTiles.splice(\r\n              uncheckedMatchingTiles.indexOf(nextTile.id),\r\n              1\r\n            );\r\n\r\n            if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n            // Generate new ranges to check\r\n            uncheckedMatchingTiles.forEach((tile) => {\r\n              checkRangeX.push(tile % boardWidthWithEdges);\r\n              checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n            });\r\n\r\n            if (uncheckedMatchingTiles.length > 1) {\r\n              checkRangeX.sort((a, b) => a - b);\r\n              checkRangeY.sort((a, b) => a - b);\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          // Obstruction in the path. Skip.\r\n          if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n            continue;\r\n          }\r\n\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // Branch out to different segments if necessary.\r\n          // On second segment, only check if on same row.\r\n          if (\r\n            path.length < 3 &&\r\n            !(\r\n              path.length === 2 &&\r\n              !checkRangeY.includes(\r\n                nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n              )\r\n            )\r\n          ) {\r\n            if (checkRangeX[0] < nextTile.id % boardWidthWithEdges) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n              paths.push(newPath);\r\n            }\r\n\r\n            if (checkRangeX.at(-1) > nextTile.id % boardWidthWithEdges) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n              paths.push(newPath);\r\n            }\r\n          }\r\n\r\n          // Path is going too far away from the range or is nearing the edge\r\n          // of the board.\r\n          if (\r\n            (path.length === 2 &&\r\n              checkRangeY.at(-1) <\r\n                nextTile.id - (nextTile.id % boardWidthWithEdges)) ||\r\n            nextTile.id >= boardWidthWithEdges * (boardHeightWithEdges - 1)\r\n          ) {\r\n            continue;\r\n          }\r\n\r\n          paths.push(path);\r\n          continue;\r\n        case \"U\":\r\n          nextTile = board[lastTile - boardWidthWithEdges];\r\n\r\n          // Did we find a path?\r\n          if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n            validMatches.push([tile.id, nextTile.id]);\r\n\r\n            uncheckedMatchingTiles.splice(\r\n              uncheckedMatchingTiles.indexOf(nextTile.id),\r\n              1\r\n            );\r\n\r\n            if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n            // Generate new ranges to check\r\n            uncheckedMatchingTiles.forEach((tile) => {\r\n              checkRangeX.push(tile % boardWidthWithEdges);\r\n              checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n            });\r\n\r\n            if (uncheckedMatchingTiles.length > 1) {\r\n              checkRangeX.sort((a, b) => a - b);\r\n              checkRangeY.sort((a, b) => a - b);\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          // Obstruction in the path. Skip.\r\n          if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n            continue;\r\n          }\r\n\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // Branch out to different segments if necessary.\r\n          // On second segment, only check if on same row.\r\n          if (\r\n            path.length < 3 &&\r\n            !(\r\n              path.length === 2 &&\r\n              !checkRangeY.includes(\r\n                nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n              )\r\n            )\r\n          ) {\r\n            if (checkRangeX[0] < nextTile.id % boardWidthWithEdges) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n              paths.push(newPath);\r\n            }\r\n\r\n            if (checkRangeX.at(-1) > nextTile.id % boardWidthWithEdges) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n              paths.push(newPath);\r\n            }\r\n          }\r\n\r\n          // Path is going too far away from the range or is nearing the edge\r\n          // of the board.\r\n          if (\r\n            (path.length === 2 &&\r\n              checkRangeY[0] >\r\n                nextTile.id - (nextTile.id % boardWidthWithEdges)) ||\r\n            nextTile.id < boardWidthWithEdges\r\n          ) {\r\n            continue;\r\n          }\r\n\r\n          paths.push(path);\r\n          continue;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n  });\r\n\r\n  return validMatches;\r\n}\r\n","import './App.css';\n\nimport Game from './game/Game.js'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Game/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}