{"version":3,"sources":["game/Tile.js","game/PathNode.js","game/GameTimer.js","game/modal/SettingsModalBody.js","game/modal/NewBoardModalBody.js","game/modal/AdvancedSettingsModalBody.js","game/modal/GameWinModalBody.js","game/modal/GameLoseModalBody.js","game/Game.js","game/BoardGenerator.js","game/PathLogic.js","App.js","serviceWorkerRegistration.js","reportWebVitals.js","index.js"],"names":["Tile","props","tileNum","parseInt","tile","isNaN","glyph","className","tileStatusClass","selected","hinted","highlighted","tileColorClass","fixChromeAndroidEmojiBug","pointer","fade","onClick","String","fromCodePoint","PathNode","node","length","nodeClass","forEach","dir","index","concat","GameTimer","React","forwardRef","ref","useStopwatch","autoStart","seconds","minutes","hours","start","pause","reset","useImperativeHandle","style","textAlign","toString","padStart","SettingsModalBody","seed","layout","tilesMatchable","newBoardModal","handleResetBoard","handleUndoMatch","disabled","canUndo","advancedSettingsModal","NewBoardModalBody","useState","prevWidth","boardWidth","setBoardWidth","prevHeight","boardHeight","setBoardHeight","customWidth","setCustomWidth","customHeight","setCustomHeight","prevBlindShuffle","blindShuffle","setBlindShuffle","prevNoSinglePairs","noSinglePairs","setNoSinglePairs","prevSeed","setSeed","useCustomSeed","setUseCustomSeed","useCustomSize","setUseCustomSize","sizeSelected","setSizeSelected","type","name","id","value","onChange","htmlFor","visibility","min","max","v","target","checked","backModal","AdvancedSettingsModalBody","toggleHighlightAllMatches","toggleHighlightMatchesForTile","toggleEmojiMode","GameWinModalBody","numTiles","clearTimeHours","clearTimeMinutes","clearTimeSeconds","GameLoseModalBody","remainingTiles","ReactModal","setAppElement","document","getElementById","Game","gameStateVer","state","useEmoji","allowDeselect","showMatchingTiles","showAllValidMatches","gameEnded","showModal","modalState","layoutDescription","tiles","selectedTile","totalMatchableTiles","tileHistory","hintedTiles","allValidMatchingTiles","pathingTiles","pathingTilesAlt","useAltPathingTiles","horizontalTileMap","verticalTileMap","timerRef","createRef","this","checkFontCompatibility","gameState","getStateFromLocal","setState","map","t","i","char","inRemovalAnim","generateHorizontalMap","generateVerticalMap","checkAllValidMatches","newTimer","Date","setSeconds","getSeconds","timer","current","resetBoard","localStorage","setItem","getItem","removeItem","e","gameStateJson","JSON","parse","stringify","navigator","userAgentData","getHighEntropyValues","then","ua","platform","platformVersion","window","test","userAgent","brands","some","item","brand","mobile","includes","width","height","generatedBoard","_width","undefined","_height","_blindShuffle","_noSinglePairs","allValidTiles","chardupe","randValue","finalSeed","seedrandom","int32","seededRng","usedTiles","Array","keys","Math","floor","oddNumberOfTiles","x","push","y","generateBoardWithSimpleShuffle","orderedTilePairs","allTileValues","numOfPairs","slice","sort","a","b","shuffledTilePairs","edgeTiles","tileValue","filter","possibleMatches","board","boardWidthWithEdges","boardHeightWithEdges","validMatchingTiles","uncheckedMatchingTiles","checkRangeX","checkRangeY","paths","segment","path","pop","curSegment","at","lastTile","nextTile","lines","splice","indexOf","newPath","getMatchingEdgeTilesInPresolvedShuffle","console","warn","possibleMatchesMultiLine","matchingTile","generateBoardWithPresolvedShuffle","allValidMatches","saveStateToLocal","validMatches","checkAllPossibleMatches","Set","flat","tileId","firstTile","secondTile","simplestPath","tileXdelta","tileYdelta","unshift","checkSimplestPath","newTiles","tile1","tile2","line","prevState","hideModal","lastMatch","bind","undoMatch","tileMap","renderTileAndPath","_el","reverse","tileobj","boardprefix","handleTileClick","renderHorizontalMap","renderVerticalMap","isOpen","contentLabel","onRequestClose","shouldCloseOnOverlayClick","renderModalBody","Component","App","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","config","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","controller","onUpdate","onSuccess","catch","error","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","URL","process","href","origin","addEventListener","fetch","headers","response","contentType","get","status","ready","unregister","reload","checkValidServiceWorker","serviceWorkerRegistration"],"mappings":"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","file":"static/js/main.c02b4b8e.chunk.js","sourcesContent":["export default function Tile(props) {\r\n  // Number between 0-42, corresponding to the Mahjong Tiles Unicode block.\r\n  let tileNum = parseInt(props.tile, 10);\r\n\r\n  // Check if tile is valid.\r\n  if (isNaN(tileNum) || tileNum < 0 || tileNum >= 43) {\r\n    return props.glyph ? (\r\n      <span className=\"game-tile-glyph game-tile-empty\">&#x1F02B;&#xFE0E;</span>\r\n    ) : (\r\n      <span className=\"game-tile-emoji game-tile-empty\">&#x1F02B;</span>\r\n    );\r\n  }\r\n\r\n  let tileStatusClass = \"\";\r\n\r\n  if (props.selected) tileStatusClass = \"game-tile-selected\";\r\n  else if (props.hinted) tileStatusClass = \"game-tile-hinted\";\r\n  else if (props.highlighted) tileStatusClass = \"game-tile-highlighted\";\r\n\r\n  if (props.glyph) {\r\n    // If the font uses the glyph variant, give them a colorized border.\r\n    let tileColorClass = \"\";\r\n\r\n    if ((tileNum >= 7 && tileNum <= 15) || tileNum === 4) {\r\n      tileColorClass = \"game-tile-glyph-red\";\r\n      if (tileNum === 4 && props.fixChromeAndroidEmojiBug) tileNum = 6;\r\n    } else if ((tileNum >= 16 && tileNum <= 24) || tileNum === 5) {\r\n      tileColorClass = \"game-tile-glyph-green\";\r\n    } else if ((tileNum >= 25 && tileNum <= 33) || tileNum === 6) {\r\n      tileColorClass = \"game-tile-glyph-blue\";\r\n    } else if (tileNum >= 34 && tileNum <= 37) {\r\n      tileColorClass = \"game-tile-glyph-flowers\";\r\n    } else if (tileNum >= 38 && tileNum <= 41) {\r\n      tileColorClass = \"game-tile-glyph-seasons\";\r\n    }\r\n\r\n    return (\r\n      <span\r\n        className={`game-tile-glyph ${tileColorClass} ${tileStatusClass} ${\r\n          props.pointer ? \"game-tile-pointer\" : \"\"\r\n        } ${props.fade ? \"game-tile-anim-fadeout\" : \"\"}`}\r\n        onClick={props.onClick}\r\n      >\r\n        {String.fromCodePoint(0x1f000 + tileNum)}&#xFE0E;\r\n      </span>\r\n    );\r\n  } else {\r\n    return (\r\n      <span\r\n        className={`game-tile-emoji ${tileStatusClass} ${\r\n          props.pointer ? \"game-tile-pointer\" : \"\"\r\n        } ${props.fade ? \"game-tile-anim-fadeout\" : \"\"}`}\r\n        onClick={props.onClick}\r\n      >\r\n        {String.fromCodePoint(0x1f000 + tileNum)}\r\n      </span>\r\n    );\r\n  }\r\n}\r\n","export default function PathNode(props) {\r\n  if (props.node && props.node.length > 0) {\r\n    let nodeClass = \"\";\r\n\r\n    props.node.forEach((dir, index) => {\r\n      if (index === 0) nodeClass = \"game-path-\";\r\n      nodeClass = nodeClass.concat(dir);\r\n    });\r\n\r\n    return <span className={`game-path ${nodeClass} game-path-anim-fadeout`} />;\r\n  }\r\n\r\n  return null;\r\n}\r\n","import React from \"react\";\r\nimport { useStopwatch } from \"react-timer-hook\";\r\n\r\nconst GameTimer = React.forwardRef((props, ref) => {\r\n  const { seconds, minutes, hours, start, pause, reset } = useStopwatch({\r\n    autoStart: true,\r\n  });\r\n\r\n  React.useImperativeHandle(ref, () => ({\r\n    start,\r\n    pause,\r\n    reset,\r\n    seconds,\r\n    minutes,\r\n    hours\r\n  }));\r\n\r\n  return (\r\n    <span style={{ textAlign: \"center\" }}>\r\n      {hours.toString().padStart(2, \"0\")}:{minutes.toString().padStart(2, \"0\")}:\r\n      {seconds.toString().padStart(2, \"0\")}\r\n    </span>\r\n  );\r\n});\r\n\r\nexport default GameTimer;\r\n","const SettingsModalBody = (props) => {\r\n  return (\r\n    <div>\r\n      <div>Board #{props.seed}, {props.layout}</div>\r\n      <div>\r\n        Current number of tiles that can be matched: {props.tilesMatchable}\r\n      </div>\r\n      <div>\r\n        <button onClick={props.newBoardModal}>Start New Board</button>\r\n      </div>\r\n      <div>\r\n        <button onClick={() => props.handleResetBoard(props.seed)}>\r\n          Reset Current Board\r\n        </button>\r\n      </div>\r\n      <div>\r\n        <button onClick={props.handleUndoMatch} disabled={props.canUndo}>\r\n          Undo Last Match\r\n        </button>\r\n      </div>\r\n      <div>\r\n        <button onClick={props.advancedSettingsModal}>Advanced Options</button>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default SettingsModalBody;\r\n","import React, { useState } from \"react\";\r\n\r\nconst NewBoardModalBody = (props) => {\r\n  const [boardWidth, setBoardWidth] = useState(props.prevWidth);\r\n  const [boardHeight, setBoardHeight] = useState(props.prevHeight);\r\n  const [customWidth, setCustomWidth] = useState(props.prevWidth);\r\n  const [customHeight, setCustomHeight] = useState(props.prevHeight);\r\n  const [blindShuffle, setBlindShuffle] = useState(props.prevBlindShuffle);\r\n  const [noSinglePairs, setNoSinglePairs] = useState(props.prevNoSinglePairs);\r\n  const [seed, setSeed] = useState(props.prevSeed);\r\n\r\n  const [useCustomSeed, setUseCustomSeed] = useState(false);\r\n  const [useCustomSize, setUseCustomSize] = useState(false);\r\n\r\n  const [sizeSelected, setSizeSelected] = useState(false);\r\n\r\n  return (\r\n    <div>\r\n      <h1>Start New Board</h1>\r\n      <div>\r\n        <h2>Board Size</h2>\r\n        <div>\r\n          <input\r\n            type=\"radio\"\r\n            name=\"size\"\r\n            id=\"sizeShort\"\r\n            value=\"short\"\r\n            onChange={() => {\r\n              setBoardWidth(8);\r\n              setBoardHeight(5);\r\n              setUseCustomSize(false);\r\n              setSizeSelected(true);\r\n            }}\r\n          ></input>\r\n          <label htmlFor=\"sizeShort\">Short (8&#x2a2f;5)</label>\r\n        </div>\r\n        <div>\r\n          <input\r\n            type=\"radio\"\r\n            name=\"size\"\r\n            id=\"sizeMedium\"\r\n            value=\"medium\"\r\n            onChange={() => {\r\n              setBoardWidth(12);\r\n              setBoardHeight(7);\r\n              setUseCustomSize(false);\r\n              setSizeSelected(true);\r\n            }}\r\n          ></input>\r\n          <label htmlFor=\"sizeMedium\">Medium (12&#x2a2f;7)</label>\r\n        </div>\r\n        <div>\r\n          <input\r\n            type=\"radio\"\r\n            name=\"size\"\r\n            id=\"sizeLarge\"\r\n            value=\"large\"\r\n            onChange={() => {\r\n              setBoardWidth(17);\r\n              setBoardHeight(8);\r\n              setUseCustomSize(false);\r\n              setSizeSelected(true);\r\n            }}\r\n          ></input>\r\n          <label htmlFor=\"sizeLarge\">Large (17&#x2a2f;8)</label>\r\n        </div>\r\n        <div>\r\n          <input\r\n            type=\"radio\"\r\n            name=\"size\"\r\n            id=\"sizeCustom\"\r\n            value=\"custom\"\r\n            onChange={() => {\r\n              setUseCustomSize(true);\r\n              setSizeSelected(true);\r\n            }}\r\n          ></input>\r\n          <label htmlFor=\"sizeCustom\">Custom</label>\r\n        </div>\r\n        <div style={{ visibility: useCustomSize ? \"visible\" : \"hidden\" }}>\r\n          <input\r\n            type=\"range\"\r\n            id=\"customWidth\"\r\n            min=\"2\"\r\n            max=\"20\"\r\n            value={customWidth}\r\n            onChange={({ target: { value: v } }) => {\r\n              setCustomWidth(v);\r\n            }}\r\n          ></input>\r\n          <label htmlFor=\"customWidth\">{customWidth} Board Width</label>\r\n        </div>\r\n        <div style={{ visibility: useCustomSize ? \"visible\" : \"hidden\" }}>\r\n          <input\r\n            type=\"range\"\r\n            id=\"customHeight\"\r\n            min=\"2\"\r\n            max=\"12\"\r\n            value={customHeight}\r\n            onChange={({ target: { value: v } }) => {\r\n              setCustomHeight(v);\r\n            }}\r\n          ></input>\r\n          <label htmlFor=\"customHeight\">{customHeight} Board Height</label>\r\n        </div>\r\n      </div>\r\n      <div>\r\n        <h2>Advanced Options</h2>\r\n        <div>\r\n          <input\r\n            type=\"checkbox\"\r\n            id=\"optTrueShuffle\"\r\n            checked={blindShuffle}\r\n            onChange={() => setBlindShuffle(!blindShuffle)}\r\n          ></input>\r\n          <label htmlFor=\"optHard\">\r\n            Enable True Shuffle. This is more difficult as it may generate \r\n            unwinnable boards!\r\n          </label>\r\n        </div>\r\n        <div>\r\n          <input\r\n            type=\"checkbox\"\r\n            id=\"optNoSinglePairs\"\r\n            checked={noSinglePairs}\r\n            onChange={() => setNoSinglePairs(!noSinglePairs)}\r\n          ></input>\r\n          <label htmlFor=\"optNoSinglePairs\">\r\n            Force Multiple Pairs Per Tile. This makes smaller boards easier.\r\n          </label>\r\n        </div>\r\n        <div>\r\n          <input\r\n            type=\"checkbox\"\r\n            id=\"optSeed\"\r\n            checked={useCustomSeed}\r\n            onChange={() => setUseCustomSeed(!useCustomSeed)}\r\n          ></input>\r\n          <label htmlFor=\"optSeed\">Use custom board number</label>\r\n        </div>\r\n        <div style={{ visibility: useCustomSeed ? \"visible\" : \"hidden\" }}>\r\n          <input\r\n            type=\"text\"\r\n            id=\"optSeedNumber\"\r\n            value={seed}\r\n            onChange={({ target: { value: v } }) => {\r\n              setSeed(v);\r\n            }}\r\n          ></input>\r\n          <label htmlFor=\"optSeedNumber\">Board Number</label>\r\n        </div>\r\n      </div>\r\n      <div>\r\n        <button\r\n          disabled={!sizeSelected}\r\n          onClick={() =>\r\n            props.handleResetBoard(\r\n              useCustomSeed ? parseInt(seed) : null,\r\n              useCustomSize ? parseInt(customWidth) : boardWidth,\r\n              useCustomSize ? parseInt(customHeight) : boardHeight,\r\n              blindShuffle,\r\n              noSinglePairs\r\n            )\r\n          }\r\n        >\r\n          Start New Board\r\n        </button>\r\n      </div>\r\n      <div>\r\n        <button onClick={props.backModal}>Go Back</button>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default NewBoardModalBody;\r\n","const AdvancedSettingsModalBody = (props) => {\r\n  return (\r\n    <div>\r\n      <div>\r\n        <button onClick={props.toggleHighlightAllMatches}>\r\n          Toggle Highlight All Matches\r\n        </button>\r\n        <button onClick={props.toggleHighlightMatchesForTile}>\r\n          Toggle Highlight Matching Tiles\r\n        </button>\r\n        <button onClick={props.toggleEmojiMode}>\r\n          Change tile type\r\n        </button>\r\n      </div>\r\n      <div>\r\n        <button onClick={props.backModal}>Back to Settings</button>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default AdvancedSettingsModalBody;\r\n","const GameWinModalBody = (props) => {\r\n  return (\r\n    <div>\r\n      <h1>You Win!</h1>\r\n      <div>\r\n        You cleared all {props.numTiles} tiles in\r\n        {props.clearTimeHours\r\n          ? ` ${props.clearTimeHours} hour${\r\n              props.clearTimeHours > 1 ? \"s\" : \"\"\r\n            }` + (props.clearTimeMinutes || props.clearTimeSeconds ? \",\" : \"\")\r\n          : \"\"}\r\n        {props.clearTimeMinutes\r\n          ? ` ${props.clearTimeMinutes} minute${\r\n              props.clearTimeMinutes > 1 ? \"s\" : \"\"\r\n            }` + (props.clearTimeSeconds ? \",\" : \"\")\r\n          : \"\"}\r\n        {props.clearTimeSeconds\r\n          ? ` ${props.clearTimeSeconds} second${\r\n              props.clearTimeSeconds > 1 ? \"s\" : \"\"\r\n            }`\r\n          : \"\"}\r\n        !\r\n      </div>\r\n      <div>\r\n        Board #{props.seed}, {props.layout}\r\n      </div>\r\n      <div>\r\n        <button onClick={props.handleResetBoard}>\r\n          Start New Board with Same Layout\r\n        </button>\r\n      </div>\r\n      <div>\r\n        <button onClick={props.newBoardModal}>Start New Board</button>\r\n      </div>\r\n      <div>\r\n        <button onClick={() => props.handleResetBoard(props.seed)}>\r\n          Reset Current Board\r\n        </button>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default GameWinModalBody;\r\n","const GameLoseModalBody = (props) => {\r\n  return (\r\n    <div>\r\n      <h1>You Have No Valid Moves!</h1>\r\n      <div>\r\n        You still have {props.remainingTiles} tiles remaining, but cannot match\r\n        any more tiles!\r\n      </div>\r\n      <div>\r\n        Board #{props.seed}, {props.layout}\r\n      </div>\r\n      <div>\r\n        <button onClick={props.handleUndoMatch} disabled={props.canUndo}>\r\n          Undo Last Match\r\n        </button>\r\n      </div>\r\n      <div>\r\n        <button onClick={() => props.handleResetBoard(props.seed)}>\r\n          Reset Current Board\r\n        </button>\r\n      </div>\r\n      <div>\r\n        <button onClick={props.handleResetBoard}>\r\n          Start New Board with Same Layout\r\n        </button>\r\n      </div>\r\n      <div>\r\n        <button onClick={props.newBoardModal}>Start New Board</button>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default GameLoseModalBody;\r\n","import React from \"react\";\r\nimport ReactModal from \"react-modal\";\r\n\r\nimport { checkSimplestPath, checkAllPossibleMatches } from \"./PathLogic.js\";\r\nimport {\r\n  generateBoardWithSimpleShuffle,\r\n  generateBoardWithPresolvedShuffle,\r\n} from \"./BoardGenerator.js\";\r\n\r\nimport Tile from \"./Tile.js\";\r\nimport PathNode from \"./PathNode.js\";\r\nimport GameTimer from \"./GameTimer.js\";\r\n\r\nimport SettingsModalBody from \"./modal/SettingsModalBody.js\";\r\nimport NewBoardModalBody from \"./modal/NewBoardModalBody.js\";\r\nimport AdvancedSettingsModalBody from \"./modal/AdvancedSettingsModalBody.js\";\r\nimport GameWinModalBody from \"./modal/GameWinModalBody.js\";\r\nimport GameLoseModalBody from \"./modal/GameLoseModalBody.js\";\r\n\r\nimport \"./Game.css\";\r\nimport \"./Modal.css\";\r\nimport \"./GameBar.css\";\r\n\r\nReactModal.setAppElement(document.getElementById(\"root\"));\r\n\r\nexport default class Game extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.gameStateVer = 3;\r\n\r\n    this.state = {\r\n      // Settings\r\n      useEmoji: false,\r\n      allowDeselect: true,\r\n      showMatchingTiles: false,\r\n      showAllValidMatches: false,\r\n      fixChromeAndroidEmojiBug: false,\r\n      // Game State\r\n      gameEnded: false,\r\n      // Modal\r\n      showModal: false,\r\n      modalState: null,\r\n      // Board Generation Options\r\n      boardWidth: 17,\r\n      boardHeight: 8,\r\n      seed: 1,\r\n      blindShuffle: false,\r\n      noSinglePairs: false,\r\n      layoutDescription: \"Rectangle 17\\u2a2f8\",\r\n      // Tile State\r\n      tiles: [],\r\n      selectedTile: null,\r\n      totalMatchableTiles: 136,\r\n      // Tile History\r\n      tileHistory: [],\r\n      // Tile Hinting\r\n      hintedTiles: [],\r\n      allValidMatchingTiles: [],\r\n      // Pathing Maps\r\n      pathingTiles: [],\r\n      pathingTilesAlt: [],\r\n      useAltPathingTiles: false,\r\n      // Tile Display Maps\r\n      horizontalTileMap: [],\r\n      verticalTileMap: [],\r\n    };\r\n\r\n    this.timerRef = React.createRef();\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.checkFontCompatibility();\r\n\r\n    const gameState = this.getStateFromLocal();\r\n\r\n    if (\r\n      gameState !== null &&\r\n      \"v\" in gameState &&\r\n      gameState.v === this.gameStateVer\r\n    ) {\r\n      try {\r\n        this.setState(\r\n          {\r\n            tiles: gameState.tiles.map((t, i) => ({\r\n              id: i,\r\n              char: t,\r\n              inRemovalAnim: false,\r\n            })),\r\n            boardWidth: gameState.boardWidth,\r\n            boardHeight: gameState.boardHeight,\r\n            seed: gameState.seed,\r\n            blindShuffle: gameState.blindShuffle,\r\n            noSinglePairs: gameState.noSinglePairs,\r\n            layoutDescription: gameState.layoutDescription,\r\n            totalMatchableTiles: gameState.totalMatchableTiles,\r\n            tileHistory: gameState.tileHistory,\r\n          },\r\n          () => {\r\n            this.generateHorizontalMap();\r\n            this.generateVerticalMap();\r\n\r\n            this.checkAllValidMatches();\r\n\r\n            const newTimer = new Date();\r\n\r\n            newTimer.setSeconds(\r\n              newTimer.getSeconds() +\r\n                gameState.timer.seconds +\r\n                gameState.timer.minutes * 60 +\r\n                gameState.timer.hours * 3600\r\n            );\r\n\r\n            this.timerRef.current.reset(newTimer);\r\n          }\r\n        );\r\n      } catch {\r\n        this.resetBoard(null, 17, 8);\r\n      }\r\n    } else {\r\n      this.resetBoard();\r\n    }\r\n  }\r\n\r\n  getStateFromLocal() {\r\n    // Check if LocalStorage is active.\r\n    if (typeof localStorage !== \"undefined\") {\r\n      try {\r\n        localStorage.setItem(\"test\", \"1\");\r\n        if (localStorage.getItem(\"test\") === \"1\") {\r\n          localStorage.removeItem(\"test\");\r\n        }\r\n      } catch (e) {\r\n        return null;\r\n      }\r\n    } else {\r\n      return null;\r\n    }\r\n\r\n    const gameStateJson = localStorage.getItem(\"gamestate\");\r\n\r\n    if (gameStateJson !== null) {\r\n      return JSON.parse(gameStateJson);\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  saveStateToLocal() {\r\n    // Check if LocalStorage is active.\r\n    if (typeof localStorage !== \"undefined\") {\r\n      try {\r\n        localStorage.setItem(\"test\", \"1\");\r\n        if (localStorage.getItem(\"test\") === \"1\") {\r\n          localStorage.removeItem(\"test\");\r\n        }\r\n      } catch (e) {\r\n        return;\r\n      }\r\n    } else {\r\n      return;\r\n    }\r\n\r\n    localStorage.setItem(\r\n      \"gamestate\",\r\n      JSON.stringify({\r\n        v: this.gameStateVer,\r\n        tiles: this.state.tiles.map((t) => (t.inRemovalAnim ? null : t.char)),\r\n        boardWidth: this.state.boardWidth,\r\n        boardHeight: this.state.boardHeight,\r\n        seed: this.state.seed,\r\n        blindShuffle: this.state.blindShuffle,\r\n        noSinglePairs: this.state.noSinglePairs,\r\n        layoutDescription: this.state.layoutDescription,\r\n        totalMatchableTiles: this.state.totalMatchableTiles,\r\n        tileHistory: this.state.tileHistory,\r\n        timer: {\r\n          seconds: this.timerRef.current.seconds,\r\n          minutes: this.timerRef.current.minutes,\r\n          hours: this.timerRef.current.hours,\r\n        },\r\n      })\r\n    );\r\n  }\r\n\r\n  checkFontCompatibility() {\r\n    // Checks with some font issues, namely with regards to emojis.\r\n\r\n    // Currently, all mahjong tiles are Non-RGI with the exception of Red Dragon,\r\n    // and the only system font that supports all of these tiles as emojis is the\r\n    // Segoe UI Emoji family, included in Windows 10+.\r\n    //\r\n    // It is unlikely that future Unicode Emoji specifications will support\r\n    // all tiles as RGI, and I'm unsure if other system font providers will\r\n    // support them. So for now, we'll just assume that only desktop Windows 10+\r\n    // can run the emoji mode.\r\n\r\n    // If we don't care that it breaks previous Windows versions, we can just\r\n    // use the is-windows package. But for compatibility, we'll just use the UA-CH\r\n    // API.\r\n    if (navigator.userAgentData)\r\n      navigator.userAgentData\r\n        .getHighEntropyValues([\"platform\", \"platformVersion\"])\r\n        .then((ua) => {\r\n          if (ua.platform === \"Windows\" && parseInt(ua.platformVersion) >= 10) {\r\n            console.log(\"Windows 10+ detected, using emoji tiles.\");\r\n            this.setState({ useEmoji: true });\r\n          }\r\n        });\r\n    else if (\r\n      window.navigator &&\r\n      /Windows NT \\d{2}/.test(window.navigator.userAgent)\r\n    ) {\r\n      console.log(\"Windows 10+ detected, using emoji tiles.\");\r\n      this.setState({ useEmoji: true });\r\n    }\r\n\r\n    // Chrome for Android has a bug where it'll not respect VS15/U+FE0E and\r\n    // always render the Red Dragon tile as emoji. For compatibility sake, just\r\n    // change it to a red version of the blue White Dragon tile.\r\n    if (\r\n      navigator.userAgentData\r\n        ? navigator.userAgentData.brands.some((item) => {\r\n            return item.brand === \"Chromium\";\r\n          }) === true && navigator.userAgentData.mobile === true\r\n        : window.navigator &&\r\n          window.navigator.userAgent.includes(\"Chrome\") &&\r\n          window.navigator.userAgent.includes(\"Mobile\")\r\n    ) {\r\n      this.setState({ fixChromeAndroidEmojiBug: true });\r\n    }\r\n  }\r\n\r\n  resetBoard(seed, width, height, blindShuffle, noSinglePairs) {\r\n    const _width = width !== undefined ? width : this.state.boardWidth,\r\n      _height = height !== undefined ? height : this.state.boardHeight,\r\n      _blindShuffle =\r\n        blindShuffle !== undefined ? blindShuffle : this.state.blindShuffle,\r\n      _noSinglePairs =\r\n        noSinglePairs !== undefined ? noSinglePairs : this.state.noSinglePairs;\r\n\r\n    let generatedBoard;\r\n\r\n    if (_blindShuffle) {\r\n      generatedBoard = generateBoardWithSimpleShuffle(\r\n        seed,\r\n        _width,\r\n        _height,\r\n        _noSinglePairs\r\n      );\r\n    } else {\r\n      generatedBoard = generateBoardWithPresolvedShuffle(\r\n        seed,\r\n        _width,\r\n        _height,\r\n        _noSinglePairs\r\n      );\r\n    }\r\n\r\n    const layoutDescription = `Rectangle ${_width}\\u2a2f${_height}${\r\n      _blindShuffle ? \" TrueShuffle\" : \"\"\r\n    }${_noSinglePairs ? \" NoSinglePairs\" : \"\"}`;\r\n\r\n    this.setState(\r\n      {\r\n        tiles: generatedBoard.tiles,\r\n        boardWidth: _width,\r\n        boardHeight: _height,\r\n        seed: generatedBoard.seed,\r\n        blindShuffle: _blindShuffle,\r\n        noSinglePairs: _noSinglePairs,\r\n        layoutDescription: layoutDescription,\r\n        totalMatchableTiles: generatedBoard.totalMatchableTiles,\r\n        selectedTile: null,\r\n        tileHistory: [],\r\n        hintedTiles: [],\r\n        allValidMatches: [],\r\n        pathingTiles: [],\r\n        pathingTilesAlt: [],\r\n        showModal: false,\r\n        gameEnded: false,\r\n      },\r\n      () => {\r\n        this.generateHorizontalMap();\r\n        this.generateVerticalMap();\r\n\r\n        this.checkAllValidMatches();\r\n        this.timerRef.current.reset();\r\n\r\n        this.saveStateToLocal();\r\n      }\r\n    );\r\n  }\r\n\r\n  checkAllValidMatches() {\r\n    const allValidMatches = checkAllPossibleMatches(\r\n      this.state.tiles,\r\n      this.state.boardWidth,\r\n      this.state.boardHeight\r\n    );\r\n\r\n    console.log(\r\n      `Number of Valid Matches: ${allValidMatches.length}` +\r\n        (this.state.showAllValidMatches === true\r\n          ? \", Valid Matches: \" +\r\n            allValidMatches.reduce(\r\n              (a, b) =>\r\n                a.concat(\r\n                  `[${(b[0] % (this.state.boardWidth + 2)) - 1 + 1},${\r\n                    (b[0] -\r\n                      (b[0] % (this.state.boardWidth + 2)) -\r\n                      (this.state.boardWidth + 2)) /\r\n                      (this.state.boardWidth + 2) +\r\n                    1\r\n                  } <-> ${(b[1] % (this.state.boardWidth + 2)) - 1 + 1},${\r\n                    (b[1] -\r\n                      (b[1] % (this.state.boardWidth + 2)) -\r\n                      (this.state.boardWidth + 2)) /\r\n                      (this.state.boardWidth + 2) +\r\n                    1\r\n                  }] `\r\n                ),\r\n              \"\"\r\n            )\r\n          : \"\")\r\n    );\r\n\r\n    this.setState(\r\n      {\r\n        allValidMatchingTiles: [...new Set(allValidMatches.flat())],\r\n      },\r\n      () => {\r\n        // If there are no matching tiles, then we either won or lost the game.\r\n        if (allValidMatches.length === 0) {\r\n          this.timerRef.current.pause();\r\n          this.setState({ gameEnded: true });\r\n\r\n          if (\r\n            this.state.totalMatchableTiles - this.state.tileHistory.length * 2 >\r\n            0\r\n          )\r\n            this.showModal(\"Game Lost\");\r\n          else this.showModal(\"Game Won\");\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  handleTileClick(tileId) {\r\n    // Don't click empty or tiles being removed.\r\n    if (\r\n      this.state.tiles[tileId].char === null ||\r\n      this.state.tiles[tileId].inRemovalAnim === true\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // Clicking the same tile either de-selects the tile or does nothing.\r\n    if (this.state.selectedTile === tileId) {\r\n      if (this.state.allowDeselect === true) {\r\n        this.setState({ selectedTile: null, hintedTiles: [] });\r\n        console.debug(`Unclicked ${tileId}`);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    console.debug(`Clicked ${tileId}`);\r\n\r\n    // If selecting a second tile, check to make sure it matches the first,\r\n    // then check the pathing to see if it's valid, then clear valid matches.\r\n    if (\r\n      this.state.selectedTile !== null &&\r\n      this.state.tiles[tileId].char ===\r\n        this.state.tiles[this.state.selectedTile].char\r\n    ) {\r\n      const path = checkSimplestPath(\r\n        tileId,\r\n        this.state.selectedTile,\r\n        this.state.tiles.slice(),\r\n        this.state.boardWidth,\r\n        this.state.boardHeight\r\n      );\r\n\r\n      if (path !== null) {\r\n        // Create an updated board, first by removing the tiles in its\r\n        // fadeout animation, then putting the match in that same animation.\r\n        const newTiles = this.state.tiles.slice();\r\n\r\n        newTiles.forEach((tile) => {\r\n          if (tile.inRemovalAnim === true) {\r\n            tile.inRemovalAnim = false;\r\n            tile.char = null;\r\n          }\r\n        });\r\n\r\n        newTiles[tileId].inRemovalAnim = true;\r\n        newTiles[this.state.selectedTile].inRemovalAnim = true;\r\n\r\n        const tileHistory = this.state.tileHistory.slice();\r\n\r\n        tileHistory.push({\r\n          char: this.state.tiles[tileId].char,\r\n          tile1: tileId,\r\n          tile2: this.state.selectedTile,\r\n        });\r\n\r\n        // Generate the pathing tiles for display.\r\n        const pathingTiles = this.state.tiles.map(() => []);\r\n\r\n        path.forEach((line) => {\r\n          line.segment.forEach((node) => {\r\n            pathingTiles[node].push(line.dir);\r\n          });\r\n        });\r\n\r\n        pathingTiles[this.state.selectedTile].push(\"-start\");\r\n        pathingTiles[tileId].push(\"-end\");\r\n\r\n        this.setState(\r\n          {\r\n            tiles: newTiles,\r\n            selectedTile: null,\r\n            tileHistory: tileHistory,\r\n            hintedTiles: [],\r\n          },\r\n          () => {\r\n            this.checkAllValidMatches();\r\n            if (!this.state.gameEnded) this.saveStateToLocal();\r\n          }\r\n        );\r\n\r\n        // Switch between primary and alternate pathing maps. This is used\r\n        // as a makeshift solution to consecutive matches using the same tile\r\n        // path, as the CSS animation doesn't get reset.\r\n        if (this.state.useAltPathingTiles === true)\r\n          this.setState((prevState) => ({\r\n            pathingTiles: prevState.tiles.map(() => []),\r\n            pathingTilesAlt: pathingTiles,\r\n            useAltPathingTiles: false,\r\n          }));\r\n        else\r\n          this.setState((prevState) => ({\r\n            pathingTiles: pathingTiles,\r\n            pathingTilesAlt: prevState.tiles.map(() => []),\r\n            useAltPathingTiles: true,\r\n          }));\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Update the hinting system, if it's enabled.\r\n    if (this.state.showMatchingTiles === true) {\r\n      const hintedTiles = this.state.tiles.filter(\r\n        (t) => t.char === this.state.tiles[tileId].char\r\n      );\r\n\r\n      this.setState({ hintedTiles: hintedTiles, selectedTile: tileId });\r\n      return;\r\n    }\r\n\r\n    this.setState({ selectedTile: tileId });\r\n  }\r\n\r\n  undoMatch(hideModal) {\r\n    if (this.state.tileHistory.length > 0) {\r\n      const newTiles = this.state.tiles.slice();\r\n      const lastMatch = this.state.tileHistory.pop();\r\n\r\n      newTiles[lastMatch.tile1].char = lastMatch.char;\r\n      newTiles[lastMatch.tile1].inRemovalAnim = false;\r\n\r\n      newTiles[lastMatch.tile2].char = lastMatch.char;\r\n      newTiles[lastMatch.tile2].inRemovalAnim = false;\r\n\r\n      this.setState(\r\n        {\r\n          tiles: newTiles,\r\n          hintedTiles: [],\r\n          pathingTiles: [],\r\n          pathingTilesAlt: [],\r\n          selectedTile: null,\r\n          gameEnded: false,\r\n        },\r\n        () => {\r\n          if (hideModal) this.hideModal();\r\n          this.checkAllValidMatches();\r\n          this.saveStateToLocal();\r\n        }\r\n      );\r\n    }\r\n  }\r\n\r\n  showModal(modalState) {\r\n    this.timerRef.current.pause();\r\n\r\n    if (modalState) this.setState({ showModal: true, modalState: modalState });\r\n    else this.setState({ showModal: true });\r\n  }\r\n\r\n  hideModal() {\r\n    if (!this.state.gameEnded) this.timerRef.current.start();\r\n\r\n    this.setState({ showModal: false });\r\n  }\r\n\r\n  renderModalBody(modalState) {\r\n    switch (modalState) {\r\n      case \"Settings\":\r\n        return (\r\n          <SettingsModalBody\r\n            seed={this.state.seed}\r\n            layout={this.state.layoutDescription}\r\n            canUndo={this.state.tileHistory.length === 0}\r\n            tilesMatchable={this.state.allValidMatchingTiles.length}\r\n            handleResetBoard={this.resetBoard.bind(this)}\r\n            handleUndoMatch={() => {\r\n              this.undoMatch(true);\r\n            }}\r\n            newBoardModal={() => this.showModal(\"New Board\")}\r\n            advancedSettingsModal={() => this.showModal(\"Advanced Settings\")}\r\n          />\r\n        );\r\n      case \"Advanced Settings\":\r\n        return (\r\n          <AdvancedSettingsModalBody\r\n            toggleHighlightAllMatches={() =>\r\n              this.setState((state) => ({\r\n                showAllValidMatches: !state.showAllValidMatches,\r\n              }))\r\n            }\r\n            toggleHighlightMatchesForTile={() =>\r\n              this.setState((state) => ({\r\n                showMatchingTiles: !state.showMatchingTiles,\r\n              }))\r\n            }\r\n            toggleEmojiMode={() =>\r\n              this.setState((state) => ({ useEmoji: !state.useEmoji }))\r\n            }\r\n            backModal={() => this.showModal(\"Settings\")}\r\n          />\r\n        );\r\n      case \"New Board\":\r\n        return (\r\n          <NewBoardModalBody\r\n            prevWidth={this.state.boardWidth}\r\n            prevHeight={this.state.boardHeight}\r\n            prevBlindShuffle={this.state.blindShuffle} \r\n            prevNoSinglePairs={this.state.noSinglePairs}\r\n            prevSeed={this.state.seed}\r\n            handleResetBoard={this.resetBoard.bind(this)}\r\n            backModal={() => this.showModal(\"Settings\")}\r\n          />\r\n        );\r\n      case \"Game Won\":\r\n        return (\r\n          <GameWinModalBody\r\n            numTiles={this.state.totalMatchableTiles}\r\n            clearTimeHours={this.timerRef.current.hours}\r\n            clearTimeMinutes={this.timerRef.current.minutes}\r\n            clearTimeSeconds={this.timerRef.current.seconds}\r\n            seed={this.state.seed}\r\n            layout={this.state.layoutDescription}\r\n            handleResetBoard={this.resetBoard.bind(this)}\r\n            newBoardModal={() => this.showModal(\"New Board\")}\r\n          />\r\n        );\r\n      case \"Game Lost\":\r\n        return (\r\n          <GameLoseModalBody\r\n            remainingTiles={\r\n              this.state.totalMatchableTiles - this.state.tileHistory.length * 2\r\n            }\r\n            seed={this.state.seed}\r\n            layout={this.state.layoutDescription}\r\n            canUndo={this.state.tileHistory.length === 0}\r\n            handleUndoMatch={() => this.undoMatch(true)}\r\n            handleResetBoard={this.resetBoard.bind(this)}\r\n            newBoardModal={() => this.showModal(\"New Board\")}\r\n          />\r\n        );\r\n      default:\r\n        return null;\r\n    }\r\n  }\r\n\r\n  generateHorizontalMap() {\r\n    const tileMap = [];\r\n\r\n    // Standard horizontal board. Used for landscape orientation.\r\n    for (let y = 0; y < this.state.boardHeight + 2; y++) {\r\n      tileMap[y] = this.state.tiles.slice(\r\n        y * (this.state.boardWidth + 2),\r\n        (y + 1) * (this.state.boardWidth + 2)\r\n      );\r\n    }\r\n\r\n    this.setState({ horizontalTileMap: tileMap });\r\n  }\r\n\r\n  renderHorizontalMap() {\r\n    const tileMap = [];\r\n\r\n    if (typeof this.state.horizontalTileMap === \"undefined\") {\r\n      return;\r\n    }\r\n\r\n    for (let y = 0; y < this.state.horizontalTileMap.length; y++) {\r\n      tileMap[y] = (\r\n        <div key={\"board-hori-row\" + y}>\r\n          {this.state.horizontalTileMap[y].map((i) =>\r\n            this.renderTileAndPath(i, \"hori\")\r\n          )}\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return tileMap;\r\n  }\r\n\r\n  generateVerticalMap() {\r\n    const tileMap = [];\r\n\r\n    // Rotated vertical board. Used for portrait orientation.\r\n    for (let x = 0; x < this.state.boardWidth + 2; x++) {\r\n      tileMap[x] = this.state.tiles\r\n        .filter((_el, index) => index % (this.state.boardWidth + 2) === x)\r\n        .reverse();\r\n    }\r\n\r\n    this.setState({ verticalTileMap: tileMap });\r\n  }\r\n\r\n  renderVerticalMap() {\r\n    const tileMap = [];\r\n\r\n    if (typeof this.state.verticalTileMap === \"undefined\") {\r\n      return;\r\n    }\r\n\r\n    for (let x = 0; x < this.state.verticalTileMap.length; x++) {\r\n      tileMap[x] = (\r\n        <div key={\"board-vert-row\" + x}>\r\n          {this.state.verticalTileMap[x].map((i) =>\r\n            this.renderTileAndPath(i, \"vert\")\r\n          )}\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return tileMap;\r\n  }\r\n\r\n  renderTileAndPath(tileobj, boardprefix) {\r\n    return (\r\n      <span key={tileobj.id}>\r\n        <Tile\r\n          tile={tileobj.char}\r\n          glyph={!this.state.useEmoji}\r\n          selected={tileobj.id === this.state.selectedTile}\r\n          hinted={\r\n            this.state.hintedTiles.includes(tileobj) && !tileobj.inRemovalAnim\r\n          }\r\n          highlighted={\r\n            this.state.showAllValidMatches &&\r\n            this.state.allValidMatchingTiles.includes(tileobj.id)\r\n          }\r\n          fade={tileobj.inRemovalAnim}\r\n          onClick={() => this.handleTileClick(tileobj.id)}\r\n          fixChromeAndroidEmojiBug={this.state.fixChromeAndroidEmojiBug}\r\n        />\r\n        <PathNode node={this.state.pathingTiles[tileobj.id]} />\r\n        <PathNode node={this.state.pathingTilesAlt[tileobj.id]} />\r\n      </span>\r\n    );\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        <div>\r\n          <div\r\n            className={`game-board game-board-horizontal game-board-size-${\r\n              this.state.boardHeight\r\n            } ${this.state.useEmoji ? \"game-board-emoji\" : \"game-board-glyph\"}`}\r\n          >\r\n            {this.renderHorizontalMap()}\r\n          </div>\r\n          <div\r\n            className={`game-board game-board-vertical game-board-size-${\r\n              this.state.boardHeight\r\n            } ${this.state.useEmoji ? \"game-board-emoji\" : \"game-board-glyph\"}`}\r\n          >\r\n            {this.renderVerticalMap()}\r\n          </div>\r\n        </div>\r\n        <div className=\"game-bar\">\r\n          <GameTimer ref={this.timerRef} />\r\n          <button\r\n            className={`settings-button ${\r\n              this.state.showModal ? \"settings-button-opened\" : \"\"\r\n            }`}\r\n            onClick={() => this.showModal(\"Settings\")}\r\n          >\r\n            &#x2699;\r\n          </button>\r\n          <button\r\n            className=\"undo-button\"\r\n            onClick={() => this.undoMatch(false)}\r\n            disabled={this.state.tileHistory.length === 0}\r\n          >\r\n            &#x21B6;\r\n          </button>\r\n        </div>\r\n\r\n        <ReactModal\r\n          isOpen={this.state.showModal}\r\n          contentLabel={this.state.modalState}\r\n          onRequestClose={() => this.hideModal()}\r\n          shouldCloseOnOverlayClick={false}\r\n        >\r\n          {this.renderModalBody(this.state.modalState)}\r\n          <button onClick={() => this.hideModal()}>Close</button>\r\n        </ReactModal>\r\n      </>\r\n    );\r\n  }\r\n}\r\n","import seedrandom from \"seedrandom\";\r\n\r\n// Generate a random game board by placing pairs/quadruplets of each random tile\r\n// on the board in the correct layout and then shuffling all tiles on the board\r\n// using a simple Fisher-Yates shuffle.\r\n//\r\n// Note: It'll generate a width+2 x height+2 board, with the edge row and\r\n// column being blank.\r\n//\r\n// This method is quicker and more random, but can generate an unwinnable board.\r\nexport function generateBoardWithSimpleShuffle(\r\n  seed,\r\n  width,\r\n  height,\r\n  noSinglePairs\r\n) {\r\n  const tiles = [],\r\n    allValidTiles = [];\r\n\r\n  let id = 0,\r\n    char = -1,\r\n    chardupe = -1,\r\n    randValue = 0,\r\n    totalMatchableTiles = 0;\r\n\r\n  // Determine if we need to generate a random seed\r\n  // or use a pre-determined one from the seed argument.\r\n  // This will be used in both tile selection and board shuffling.\r\n  const finalSeed = isNaN(parseInt(seed, 10))\r\n    ? seedrandom().int32() >>> 0\r\n    : parseInt(seed, 10) >>> 0;\r\n\r\n  const seededRng = seedrandom(finalSeed);\r\n\r\n  // Generate which tiles are used. This is done by listing all\r\n  // possible tiles (without duplicates), then shuffling it.\r\n  let usedTiles = [...Array(34).keys()];\r\n\r\n  // Shuffle.\r\n  for (let i = usedTiles.length - 1; i > 0; i--) {\r\n    randValue = Math.floor(seededRng() * (i + 1));\r\n\r\n    char = usedTiles[i];\r\n    usedTiles[i] = usedTiles[randValue];\r\n    usedTiles[randValue] = char;\r\n  }\r\n\r\n  // If we have an odd amount of tiles in general, both width and height are\r\n  // odd. To keep things even, we make the centermost tile empty.\r\n  const oddNumberOfTiles = width % 2 !== 0 && height % 2 !== 0;\r\n\r\n  // Generate the initial unshuffled layout of tiles.\r\n  // Blank out the top outer edge.\r\n  for (let x = 0; x < width + 2; x++)\r\n    id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n\r\n  for (let y = 0; y < height; y++) {\r\n    // Blank out the left outer edge.\r\n    id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n\r\n    for (let x = 0; x < width; x++) {\r\n      if (oddNumberOfTiles && x === width >> 1 && y === height >> 1) {\r\n        id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        (chardupe = (chardupe + 1) % (noSinglePairs === true ? 4 : 2)) === 0\r\n      ) {\r\n        char = (char + 1) % usedTiles.length;\r\n      }\r\n\r\n      allValidTiles.push(id);\r\n      id = tiles.push({\r\n        id: id,\r\n        char: usedTiles[char],\r\n        inRemovalAnim: false,\r\n      });\r\n      totalMatchableTiles++;\r\n    }\r\n\r\n    // Blank out the right outer edge.\r\n    id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n  }\r\n\r\n  // Blank out the bottom outer edge.\r\n  for (let x = 0; x < width + 2; x++)\r\n    id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n\r\n  // Shuffle the board.\r\n  for (let i = allValidTiles.length - 1; i > 0; i--) {\r\n    randValue = Math.floor(seededRng() * (i + 1));\r\n\r\n    char = tiles[allValidTiles[i]].char;\r\n    tiles[allValidTiles[i]].char = tiles[allValidTiles[randValue]].char;\r\n    tiles[allValidTiles[randValue]].char = char;\r\n  }\r\n\r\n  console.log(\r\n    `Generated simple-shuffle ${width}x${height} board with seed ${finalSeed}`\r\n  );\r\n\r\n  return {\r\n    tiles: tiles,\r\n    seed: finalSeed,\r\n    totalMatchableTiles: totalMatchableTiles,\r\n  };\r\n}\r\n\r\n// Generate a random game board by taking a complete layout of unknown tiles\r\n// and for each valid tile-match, in a random order, remove pairs from the\r\n// layout in a random formation.\r\n//\r\n// Note: It'll generate a width+2 x height+2 board, with the edge row and\r\n// column being blank.\r\n//\r\n// This method is slower, but genereates winnable boards.\r\nexport function generateBoardWithPresolvedShuffle(\r\n  seed,\r\n  width,\r\n  height,\r\n  noSinglePairs\r\n) {\r\n  const tiles = [];\r\n\r\n  let id = 0,\r\n    char = -1,\r\n    randValue = 0,\r\n    totalMatchableTiles = 0;\r\n\r\n  // Determine if we need to generate a random seed\r\n  // or use a pre-determined one from the seed argument.\r\n  // This will be used in both tile selection and board shuffling.\r\n  const finalSeed = isNaN(parseInt(seed, 10))\r\n    ? seedrandom().int32() >>> 0\r\n    : parseInt(seed, 10) >>> 0;\r\n\r\n  const seededRng = seedrandom(finalSeed);\r\n\r\n  // Generate the tile matching order for the solving algorithm. This is done\r\n  // by getting a list of valid tile pairs, then adjusting it to fit the\r\n  // layout, then shuffling it.\r\n\r\n  // For this, we are only using 34 mahjong tile values (winds, dragons,\r\n  // characters, bamboo, circles). At the moment, flowers and seasons are not\r\n  // used.\r\n  let allTileValues = [...Array(34).keys()];\r\n\r\n  // Each value in this array is a representation of a tile pair, based on its\r\n  // tile value. If \"noSinglePairs\" is true, then there are at least two pairs\r\n  // of a tile on a given board for an easier difficulty on smaller boards.\r\n  let orderedTilePairs;\r\n\r\n  const numOfPairs = (width * height) >> 1;\r\n\r\n  // If our board cannot fit pairs/quads of all tiles, we choose which of the \r\n  // tiles we use at random.\r\n  if (\r\n    numOfPairs <\r\n    (noSinglePairs ? allTileValues.length << 1 : allTileValues.length)\r\n  ) {\r\n    for (let i = allTileValues.length - 1; i > 0; i--) {\r\n      randValue = Math.floor(seededRng() * (i + 1));\r\n\r\n      char = allTileValues[i];\r\n      allTileValues[i] = allTileValues[randValue];\r\n      allTileValues[randValue] = char;\r\n    }\r\n\r\n    // Trim the number of tiles used.\r\n    //\r\n    // NOTE: If \"noSinglePairs\" is true and we have one extra pair unaccounted\r\n    // for, we'll keep with the name and have the extra pair be from one of\r\n    // the chosen tiles (which means there will be 6 instead of 4). If we'd\r\n    // rather have it be a single pair of an unused tile, replace the following:\r\n    // numofPairs >> 1           -->       (numOfPairs + 1) >> 1\r\n    allTileValues = allTileValues.slice(\r\n      0,\r\n      noSinglePairs ? numOfPairs >> 1 : numOfPairs\r\n    );\r\n  }\r\n\r\n  // Pre-fill part of the tile pair array, all the way up to one pair/quad of\r\n  // each tile value.\r\n  orderedTilePairs = noSinglePairs\r\n    ? allTileValues.concat(allTileValues)\r\n    : allTileValues.slice();\r\n\r\n  orderedTilePairs.sort((a, b) => a - b);\r\n\r\n  // If the board is too big for the amount of pairs, we add more pairs in a\r\n  // random order.\r\n  while (orderedTilePairs.length < numOfPairs) {\r\n    let shuffledTilePairs = allTileValues.slice();\r\n\r\n    for (let i = shuffledTilePairs.length - 1; i > 0; i--) {\r\n      randValue = Math.floor(seededRng() * (i + 1));\r\n\r\n      char = shuffledTilePairs[i];\r\n      shuffledTilePairs[i] = shuffledTilePairs[randValue];\r\n      shuffledTilePairs[randValue] = char;\r\n    }\r\n\r\n    orderedTilePairs = orderedTilePairs.concat(shuffledTilePairs);\r\n  }\r\n\r\n  // Crop the number of pairs to fit the target total amount.\r\n  orderedTilePairs = orderedTilePairs.slice(0, numOfPairs);\r\n\r\n  // Shuffle.\r\n  for (let i = orderedTilePairs.length - 1; i > 0; i--) {\r\n    randValue = Math.floor(seededRng() * (i + 1));\r\n\r\n    char = orderedTilePairs[i];\r\n    orderedTilePairs[i] = orderedTilePairs[randValue];\r\n    orderedTilePairs[randValue] = char;\r\n  }\r\n\r\n  // Generate the initial unshuffled layout of tiles.\r\n\r\n  // Blank out the top outer edge.\r\n  for (let x = 0; x < width + 2; x++)\r\n    id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n\r\n  for (let y = 0; y < height; y++) {\r\n    // Blank out the left outer edge.\r\n    id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n\r\n    for (let x = 0; x < width; x++) {\r\n      id = tiles.push({ id: id, char: -1, inRemovalAnim: false });\r\n      totalMatchableTiles++;\r\n    }\r\n\r\n    // Blank out the right outer edge.\r\n    id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n  }\r\n\r\n  // Blank out the bottom outer edge.\r\n  for (let x = 0; x < width + 2; x++)\r\n    id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n\r\n  // If we have an odd amount of tiles in general, both width and height are\r\n  // odd. To keep things even, we make the centermost tile empty.\r\n  if (width % 2 !== 0 && height % 2 !== 0) tiles[tiles.length >> 1].char = null;\r\n\r\n  let edgeTiles = [];\r\n\r\n  // Get all tiles with an empty edge.\r\n  for (let i = width + 2; i < tiles.length - (width + 2); i++) {\r\n    if (\r\n      tiles[i].char === -1 &&\r\n      (tiles[i - 1].char !== -1 ||\r\n        tiles[i + 1].char !== -1 ||\r\n        tiles[i - (width + 2)].char !== -1 ||\r\n        tiles[i + (width + 2)].char !== -1)\r\n    )\r\n      edgeTiles.push(i);\r\n  }\r\n\r\n  for (let i = 0; i < numOfPairs; i++) {\r\n    // Get a random unvisited edge tile.\r\n    let tileValue = edgeTiles[Math.floor(seededRng() * edgeTiles.length)];\r\n\r\n    // Add unvisited surrounding tiles to the open edge list.\r\n    if (\r\n      tiles[tileValue - 1].char === -1 &&\r\n      !edgeTiles.includes(tileValue - 1)\r\n    ) {\r\n      edgeTiles.push(tileValue - 1);\r\n    }\r\n    if (\r\n      tiles[tileValue + 1].char === -1 &&\r\n      !edgeTiles.includes(tileValue + 1)\r\n    ) {\r\n      edgeTiles.push(tileValue + 1);\r\n    }\r\n    if (\r\n      tiles[tileValue - (width + 2)].char === -1 &&\r\n      !edgeTiles.includes(tileValue - (width + 2))\r\n    ) {\r\n      edgeTiles.push(tileValue - (width + 2));\r\n    }\r\n    if (\r\n      tiles[tileValue + (width + 2)].char === -1 &&\r\n      !edgeTiles.includes(tileValue + (width + 2))\r\n    ) {\r\n      edgeTiles.push(tileValue + (width + 2));\r\n    }\r\n\r\n    // Don't match the tile with itself.\r\n    edgeTiles = edgeTiles.filter((x) => x !== tileValue);\r\n\r\n    let possibleMatches = getMatchingEdgeTilesInPresolvedShuffle(\r\n      tileValue,\r\n      tiles,\r\n      width,\r\n      height,\r\n      edgeTiles\r\n    );\r\n\r\n    if (possibleMatches === undefined || possibleMatches.length === 0) {\r\n      console.warn(\r\n        \"Presolve-shuffle detected an unmatching tile! This is bad.\"\r\n      );\r\n      continue;\r\n    }\r\n\r\n    // Prefer matches that use more than one line.\r\n    let possibleMatchesMultiLine = possibleMatches.filter((x) => x.lines > 1);\r\n\r\n    let matchingTile =\r\n      possibleMatchesMultiLine.length > 0\r\n        ? possibleMatchesMultiLine[\r\n            Math.floor(seededRng() * possibleMatchesMultiLine.length)\r\n          ].tile\r\n        : possibleMatches[Math.floor(seededRng() * possibleMatches.length)]\r\n            .tile;\r\n\r\n    // We found our pair!\r\n    tiles[tileValue].char = orderedTilePairs[i];\r\n    tiles[matchingTile].char = orderedTilePairs[i];\r\n\r\n    // Add unvisited surrounding tiles of the matched tile to the open edge list.\r\n    if (\r\n      tiles[matchingTile - 1].char === -1 &&\r\n      !edgeTiles.includes(matchingTile - 1)\r\n    ) {\r\n      edgeTiles.push(matchingTile - 1);\r\n    }\r\n    if (\r\n      tiles[matchingTile + 1].char === -1 &&\r\n      !edgeTiles.includes(matchingTile + 1)\r\n    ) {\r\n      edgeTiles.push(matchingTile + 1);\r\n    }\r\n    if (\r\n      tiles[matchingTile - (width + 2)].char === -1 &&\r\n      !edgeTiles.includes(matchingTile - (width + 2))\r\n    ) {\r\n      edgeTiles.push(matchingTile - (width + 2));\r\n    }\r\n    if (\r\n      tiles[matchingTile + (width + 2)].char === -1 &&\r\n      !edgeTiles.includes(matchingTile + (width + 2))\r\n    ) {\r\n      edgeTiles.push(matchingTile + (width + 2));\r\n    }\r\n\r\n    // Don't match future tile with the matched tile.\r\n    edgeTiles = edgeTiles.filter((x) => x !== matchingTile);\r\n  }\r\n\r\n  console.log(\r\n    `Generated presolved-shuffle ${width}x${height} board with seed ${finalSeed}`\r\n  );\r\n\r\n  return {\r\n    tiles: tiles,\r\n    seed: finalSeed,\r\n    totalMatchableTiles: totalMatchableTiles,\r\n  };\r\n}\r\n\r\nfunction getMatchingEdgeTilesInPresolvedShuffle(\r\n  tile,\r\n  board,\r\n  boardWidth,\r\n  boardHeight,\r\n  edgeTiles\r\n) {\r\n  const boardWidthWithEdges = boardWidth + 2,\r\n    boardHeightWithEdges = boardHeight + 2;\r\n\r\n  let validMatchingTiles = [];\r\n\r\n  let uncheckedMatchingTiles = edgeTiles.slice();\r\n\r\n  // Get the X and Y ranges to check. This prevents the pathing algorithm\r\n  // from exploring areas it doesn't need to.\r\n  let checkRangeX = [],\r\n    checkRangeY = [];\r\n\r\n  uncheckedMatchingTiles.forEach((tile) => {\r\n    checkRangeX.push(tile % boardWidthWithEdges);\r\n    checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n  });\r\n\r\n  if (uncheckedMatchingTiles.length > 1) {\r\n    checkRangeX.sort((a, b) => a - b);\r\n    checkRangeY.sort((a, b) => a - b);\r\n  }\r\n\r\n  // Starting paths.\r\n  let paths = [];\r\n\r\n  paths.push([{ segment: [tile], dir: \"R\" }]);\r\n  paths.push([{ segment: [tile], dir: \"L\" }]);\r\n  paths.push([{ segment: [tile], dir: \"U\" }]);\r\n  paths.push([{ segment: [tile], dir: \"D\" }]);\r\n\r\n  while (paths.length > 0) {\r\n    const path = paths.pop();\r\n\r\n    const curSegment = path.at(-1);\r\n    const lastTile = curSegment.segment.at(-1);\r\n    let nextTile;\r\n\r\n    switch (curSegment.dir) {\r\n      case \"R\":\r\n        nextTile = board[lastTile + 1];\r\n\r\n        // Did we find a path?\r\n        if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n          validMatchingTiles.push({ tile: nextTile.id, lines: path.length });\r\n\r\n          uncheckedMatchingTiles.splice(\r\n            uncheckedMatchingTiles.indexOf(nextTile.id),\r\n            1\r\n          );\r\n\r\n          if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n          // Generate new ranges to check\r\n          uncheckedMatchingTiles.forEach((tile) => {\r\n            checkRangeX.push(tile % boardWidthWithEdges);\r\n            checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n          });\r\n\r\n          if (uncheckedMatchingTiles.length > 1) {\r\n            checkRangeX.sort((a, b) => a - b);\r\n            checkRangeY.sort((a, b) => a - b);\r\n          }\r\n\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char === -1) {\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // Branch out to different segments if necessary.\r\n        // On second segment, only check if on same column.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            !checkRangeX.includes(nextTile.id % boardWidthWithEdges)\r\n          )\r\n        ) {\r\n          if (\r\n            checkRangeY[0] <\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n            paths.push(newPath);\r\n          }\r\n\r\n          if (\r\n            checkRangeY.at(-1) >\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n            paths.push(newPath);\r\n          }\r\n        }\r\n\r\n        // Path is going too far away from the range or is nearing the edge\r\n        // of the board.\r\n        if (\r\n          (path.length === 2 &&\r\n            checkRangeX.at(-1) < nextTile.id % boardWidthWithEdges) ||\r\n          nextTile.id % boardWidthWithEdges === boardWidthWithEdges - 1\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        paths.push(path);\r\n        continue;\r\n      case \"L\":\r\n        nextTile = board[lastTile - 1];\r\n\r\n        // Did we find a path?\r\n        if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n          validMatchingTiles.push({ tile: nextTile.id, lines: path.length });\r\n\r\n          uncheckedMatchingTiles.splice(\r\n            uncheckedMatchingTiles.indexOf(nextTile.id),\r\n            1\r\n          );\r\n\r\n          if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n          // Generate new ranges to check\r\n          uncheckedMatchingTiles.forEach((tile) => {\r\n            checkRangeX.push(tile % boardWidthWithEdges);\r\n            checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n          });\r\n\r\n          if (uncheckedMatchingTiles.length > 1) {\r\n            checkRangeX.sort((a, b) => a - b);\r\n            checkRangeY.sort((a, b) => a - b);\r\n          }\r\n\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char === -1) {\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // Branch out to different segments if necessary.\r\n        // On second segment, only check if on same column.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            !checkRangeX.includes(nextTile.id % boardWidthWithEdges)\r\n          )\r\n        ) {\r\n          if (\r\n            checkRangeY[0] <\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n            paths.push(newPath);\r\n          }\r\n\r\n          if (\r\n            checkRangeY.at(-1) >\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n            paths.push(newPath);\r\n          }\r\n        }\r\n\r\n        // Path is going too far away from the range or is nearing the edge\r\n        // of the board.\r\n        if (\r\n          (path.length === 2 &&\r\n            checkRangeX[0] > nextTile.id % boardWidthWithEdges) ||\r\n          nextTile.id % boardWidthWithEdges === 0\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        paths.push(path);\r\n        continue;\r\n      case \"D\":\r\n        nextTile = board[lastTile + boardWidthWithEdges];\r\n\r\n        // Did we find a path?\r\n        if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n          validMatchingTiles.push({ tile: nextTile.id, lines: path.length });\r\n\r\n          uncheckedMatchingTiles.splice(\r\n            uncheckedMatchingTiles.indexOf(nextTile.id),\r\n            1\r\n          );\r\n\r\n          if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n          // Generate new ranges to check\r\n          uncheckedMatchingTiles.forEach((tile) => {\r\n            checkRangeX.push(tile % boardWidthWithEdges);\r\n            checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n          });\r\n\r\n          if (uncheckedMatchingTiles.length > 1) {\r\n            checkRangeX.sort((a, b) => a - b);\r\n            checkRangeY.sort((a, b) => a - b);\r\n          }\r\n\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char === -1) {\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // Branch out to different segments if necessary.\r\n        // On second segment, only check if on same row.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            !checkRangeY.includes(\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            )\r\n          )\r\n        ) {\r\n          if (checkRangeX[0] < nextTile.id % boardWidthWithEdges) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n            paths.push(newPath);\r\n          }\r\n\r\n          if (checkRangeX.at(-1) > nextTile.id % boardWidthWithEdges) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n            paths.push(newPath);\r\n          }\r\n        }\r\n\r\n        // Path is going too far away from the range or is nearing the edge\r\n        // of the board.\r\n        if (\r\n          (path.length === 2 &&\r\n            checkRangeY.at(-1) <\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)) ||\r\n          nextTile.id >= boardWidthWithEdges * (boardHeightWithEdges - 1)\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        paths.push(path);\r\n        continue;\r\n      case \"U\":\r\n        nextTile = board[lastTile - boardWidthWithEdges];\r\n\r\n        // Did we find a path?\r\n        if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n          validMatchingTiles.push({ tile: nextTile.id, lines: path.length });\r\n\r\n          uncheckedMatchingTiles.splice(\r\n            uncheckedMatchingTiles.indexOf(nextTile.id),\r\n            1\r\n          );\r\n\r\n          if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n          // Generate new ranges to check\r\n          uncheckedMatchingTiles.forEach((tile) => {\r\n            checkRangeX.push(tile % boardWidthWithEdges);\r\n            checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n          });\r\n\r\n          if (uncheckedMatchingTiles.length > 1) {\r\n            checkRangeX.sort((a, b) => a - b);\r\n            checkRangeY.sort((a, b) => a - b);\r\n          }\r\n\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char === -1) {\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // Branch out to different segments if necessary.\r\n        // On second segment, only check if on same row.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            !checkRangeY.includes(\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            )\r\n          )\r\n        ) {\r\n          if (checkRangeX[0] < nextTile.id % boardWidthWithEdges) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n            paths.push(newPath);\r\n          }\r\n\r\n          if (checkRangeX.at(-1) > nextTile.id % boardWidthWithEdges) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n            paths.push(newPath);\r\n          }\r\n        }\r\n\r\n        // Path is going too far away from the range or is nearing the edge\r\n        // of the board.\r\n        if (\r\n          (path.length === 2 &&\r\n            checkRangeY[0] >\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)) ||\r\n          nextTile.id < boardWidthWithEdges\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        paths.push(path);\r\n        continue;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  return validMatchingTiles;\r\n}\r\n","/**\r\n * Check the simplest (i.e. least amount of segments) nikakudori path between\r\n * two tiles on the provided game board.\r\n *\r\n * This utilizes an iterative depth-first search approach, with special modifications\r\n * to account for the limited amount of line segments.\r\n *\r\n * @param {!number} firstTile The tile index to start from\r\n * @param {!number} secondTile The tile index to end up on\r\n * @param {!{{<id: number, char: number>}}[]} board The tiles\r\n * themselves, which should be (1 + boardWidth + 1) * (1 + boardHeight + 1)\r\n * to account for the edges.\r\n * @param {!number} boardWidth Width of the board, excluding the edges.\r\n * @param {!number} boardHeight Height of the board, excluding the edges.\r\n * @returns {?{{<segment: number[], dir: string>}}[]} An array of line segments showing\r\n * one of the simplest paths. Segments are list of tile indexes in order.\r\n * Dir can be \"U\", \"D\", \"L\", or \"R\".\r\n */\r\nexport function checkSimplestPath(\r\n  firstTile,\r\n  secondTile,\r\n  board,\r\n  boardWidth,\r\n  boardHeight\r\n) {\r\n  if (firstTile === secondTile) return null;\r\n\r\n  console.debug(\r\n    `Checking path between tile ${firstTile} and tile ${secondTile}`\r\n  );\r\n\r\n  const boardWidthWithEdges = boardWidth + 2,\r\n    boardHeightWithEdges = boardHeight + 2;\r\n\r\n  let paths = [],\r\n    simplestPath = null;\r\n\r\n  const tileXdelta =\r\n    (secondTile % boardWidthWithEdges) - (firstTile % boardWidthWithEdges);\r\n  const tileYdelta =\r\n    (secondTile -\r\n      (secondTile % boardWidthWithEdges) -\r\n      (firstTile - (firstTile % boardWidthWithEdges))) /\r\n    boardWidthWithEdges;\r\n\r\n  // Do not check opposite direction if in the same row or column.\r\n\r\n  if (tileYdelta !== 0 || tileXdelta > 0) {\r\n    paths.push([{ segment: [firstTile], dir: \"R\" }]);\r\n  }\r\n\r\n  if (tileYdelta !== 0 || tileXdelta < 0) {\r\n    if (tileXdelta < 0) paths.push([{ segment: [firstTile], dir: \"L\" }]);\r\n    else paths.unshift([{ segment: [firstTile], dir: \"L\" }]);\r\n  }\r\n\r\n  if (tileXdelta !== 0 || tileYdelta > 0) {\r\n    if (tileYdelta >= 0) paths.push([{ segment: [firstTile], dir: \"D\" }]);\r\n    else paths.unshift([{ segment: [firstTile], dir: \"D\" }]);\r\n  }\r\n\r\n  if (tileXdelta !== 0 || tileYdelta < 0) {\r\n    if (tileYdelta < 0) paths.push([{ segment: [firstTile], dir: \"U\" }]);\r\n    else paths.push([{ segment: [firstTile], dir: \"U\" }]);\r\n  }\r\n\r\n  while (paths.length > 0) {\r\n    const path = paths.pop();\r\n\r\n    console.debug(\r\n      `Checking path: ${path.at(-1).segment} | ${path.at(-1).dir} | length: ${\r\n        path.length\r\n      } | queue: ${paths.length}`\r\n    );\r\n\r\n    // If we already found a three-line path, we shouldn't look for more\r\n    // three-line paths.\r\n    if (simplestPath !== null && path.length === 3) {\r\n      continue;\r\n    }\r\n\r\n    const curSegment = path.at(-1);\r\n    const lastTile = curSegment.segment.at(-1);\r\n    let nextTile;\r\n\r\n    switch (curSegment.dir) {\r\n      case \"R\":\r\n        nextTile = board[lastTile + 1];\r\n\r\n        // We found the path, or a simpler one!\r\n        if (nextTile.id === secondTile) {\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // If it is a one-line or two-line path, it's one of the\r\n          // absolute shortest paths. We're done!\r\n          if (path.length < 3) {\r\n            return path;\r\n          }\r\n\r\n          simplestPath = path;\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // On first and second segment, check U if second tile is above and\r\n        // check D if the second tile is below.\r\n        // On second segment, only check if on same column.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            secondTile % boardWidthWithEdges !==\r\n              nextTile.id % boardWidthWithEdges\r\n          )\r\n        ) {\r\n          if (\r\n            secondTile - (secondTile % boardWidthWithEdges) <\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n            if (tileYdelta < 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          } else if (\r\n            secondTile - (secondTile % boardWidthWithEdges) >\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n            if (tileYdelta >= 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          }\r\n        }\r\n\r\n        if (\r\n          (path.length === 2 &&\r\n            secondTile % boardWidthWithEdges <\r\n              nextTile.id % boardWidthWithEdges) ||\r\n          nextTile.id % boardWidthWithEdges === boardWidthWithEdges - 1\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        if (tileXdelta >= 0) paths.push(path);\r\n        else paths.unshift(path);\r\n        continue;\r\n      case \"L\":\r\n        nextTile = board[lastTile - 1];\r\n\r\n        // We found the path, or a simpler one!\r\n        if (nextTile.id === secondTile) {\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // If it is a one-line or two-line path, it's one of the\r\n          // absolute shortest paths. We're done!\r\n          if (path.length < 3) {\r\n            return path;\r\n          }\r\n\r\n          simplestPath = path;\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // On first and second segment, check U if second tile is above and\r\n        // check D if the second tile is below.\r\n        // On second segment, only check if on same column.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            secondTile % boardWidthWithEdges !==\r\n              nextTile.id % boardWidthWithEdges\r\n          )\r\n        ) {\r\n          if (\r\n            secondTile - (secondTile % boardWidthWithEdges) <\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n            if (tileYdelta < 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          } else if (\r\n            secondTile - (secondTile % boardWidthWithEdges) >\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n            if (tileYdelta >= 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          }\r\n        }\r\n\r\n        if (\r\n          (path.length === 2 &&\r\n            secondTile % boardWidthWithEdges >\r\n              nextTile.id % boardWidthWithEdges) ||\r\n          nextTile.id % boardWidthWithEdges === 0\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        if (tileXdelta < 0) paths.push(path);\r\n        else paths.unshift(path);\r\n        continue;\r\n      case \"D\":\r\n        nextTile = board[lastTile + boardWidthWithEdges];\r\n\r\n        // We found the path, or a simpler one!\r\n        if (nextTile.id === secondTile) {\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // If it is a one-line or two-line path, it's one of the\r\n          // absolute shortest paths. We're done!\r\n          if (path.length < 3) {\r\n            return path;\r\n          }\r\n\r\n          simplestPath = path;\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // On first and second segment, check L if second tile is left and\r\n        // check R if the second tile is right.\r\n        // On second segment, only check if on same row.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            secondTile - (secondTile % boardWidthWithEdges) !==\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          )\r\n        ) {\r\n          if (\r\n            secondTile % boardWidthWithEdges <\r\n            nextTile.id % boardWidthWithEdges\r\n          ) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n            if (tileXdelta < 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          } else if (\r\n            secondTile % boardWidthWithEdges >\r\n            nextTile.id % boardWidthWithEdges\r\n          ) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n            if (tileXdelta >= 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          }\r\n        }\r\n\r\n        if (\r\n          (path.length === 2 &&\r\n            secondTile - (secondTile % boardWidthWithEdges) <\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)) ||\r\n          nextTile.id >= boardWidthWithEdges * (boardHeightWithEdges - 1)\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        if (tileYdelta >= 0) paths.push(path);\r\n        else paths.unshift(path);\r\n        continue;\r\n      case \"U\":\r\n        nextTile = board[lastTile - boardWidthWithEdges];\r\n\r\n        // We found the path, or a simpler one!\r\n        if (nextTile.id === secondTile) {\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // If it is a one-line or two-line path, it's one of the\r\n          // absolute shortest paths. We're done!\r\n          if (path.length < 3) {\r\n            return path;\r\n          }\r\n\r\n          simplestPath = path;\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // On first and second segment, check L if second tile is left and\r\n        // check R if the second tile is right.\r\n        // On second segment, only check if on same row.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            secondTile - (secondTile % boardWidthWithEdges) !==\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          )\r\n        ) {\r\n          if (\r\n            secondTile % boardWidthWithEdges <\r\n            nextTile.id % boardWidthWithEdges\r\n          ) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n            if (tileXdelta < 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          } else if (\r\n            secondTile % boardWidthWithEdges >\r\n            nextTile.id % boardWidthWithEdges\r\n          ) {\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n            if (tileXdelta >= 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          }\r\n        }\r\n\r\n        if (\r\n          (path.length === 2 &&\r\n            secondTile - (secondTile % boardWidthWithEdges) >\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)) ||\r\n          nextTile.id < boardWidthWithEdges\r\n        ) {\r\n          continue;\r\n        }\r\n\r\n        if (tileYdelta < 0) paths.push(path);\r\n        else paths.unshift(path);\r\n        continue;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  console.debug(\"Simplest path in checkSimplestPath\" + simplestPath);\r\n  return simplestPath;\r\n}\r\n\r\n/**\r\n * Check all valid matches on the current game board.\r\n *\r\n * This utilizes an depth-first search approach, with special modifications\r\n * to account for the limited amount of line segments.\r\n *\r\n * @param {!{{<id: number, char: number>}}[]} board The tiles\r\n * themselves, which should be (1 + boardWidth + 1) * (1 + boardHeight + 1)\r\n * to account for the edges.\r\n * @param {!number} boardWidth Width of the board, excluding the edges.\r\n * @param {!number} boardHeight Height of the board, excluding the edges.\r\n * @returns {?number[][]} An array of valid matching tile ID pairs.\r\n */\r\nexport function checkAllPossibleMatches(board, boardWidth, boardHeight) {\r\n  const boardWidthWithEdges = boardWidth + 2,\r\n    boardHeightWithEdges = boardHeight + 2;\r\n\r\n  let validMatches = [];\r\n\r\n  console.debug(\r\n    `Checking all possible matches for a board with dimensions ${boardWidth} x ${boardHeight}`\r\n  );\r\n\r\n  // Throw out a path for each valid tile.\r\n  board.forEach((tile) => {\r\n    // Ignore missing tiles.\r\n    if (tile.char === null || tile.inRemovalAnim === true) return;\r\n\r\n    // Check each tile for matches against later tiles. We've already checked\r\n    // against earlier tiles in earlier checks.\r\n    let uncheckedMatchingTiles = [];\r\n\r\n    for (let i = tile.id + 1; i < board.length; i++) {\r\n      if (board[i].char === tile.char && board[i].inRemovalAnim === false) {\r\n        uncheckedMatchingTiles.push(i);\r\n      }\r\n    }\r\n\r\n    // No matches to check.\r\n    if (uncheckedMatchingTiles.length === 0) return;\r\n\r\n    console.debug(\r\n      `Checking tile ${tile.id} with tiles ${uncheckedMatchingTiles}`\r\n    );\r\n\r\n    // Get the X and Y ranges to check. This prevents the pathing algorithm\r\n    // from exploring areas it doesn't need to.\r\n    let checkRangeX = [],\r\n      checkRangeY = [];\r\n\r\n    uncheckedMatchingTiles.forEach((tile) => {\r\n      checkRangeX.push(tile % boardWidthWithEdges);\r\n      checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n    });\r\n\r\n    if (uncheckedMatchingTiles.length > 1) {\r\n      checkRangeX.sort((a, b) => a - b);\r\n      checkRangeY.sort((a, b) => a - b);\r\n    }\r\n\r\n    // Starting paths.\r\n    let paths = [];\r\n\r\n    paths.push([{ segment: [tile.id], dir: \"R\" }]);\r\n    paths.push([{ segment: [tile.id], dir: \"L\" }]);\r\n    paths.push([{ segment: [tile.id], dir: \"U\" }]);\r\n    paths.push([{ segment: [tile.id], dir: \"D\" }]);\r\n\r\n    while (paths.length > 0) {\r\n      const path = paths.pop();\r\n\r\n      const curSegment = path.at(-1);\r\n      const lastTile = curSegment.segment.at(-1);\r\n      let nextTile;\r\n\r\n      switch (curSegment.dir) {\r\n        case \"R\":\r\n          nextTile = board[lastTile + 1];\r\n\r\n          // Did we find a path?\r\n          if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n            validMatches.push([tile.id, nextTile.id]);\r\n\r\n            uncheckedMatchingTiles.splice(\r\n              uncheckedMatchingTiles.indexOf(nextTile.id),\r\n              1\r\n            );\r\n\r\n            if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n            // Generate new ranges to check\r\n            uncheckedMatchingTiles.forEach((tile) => {\r\n              checkRangeX.push(tile % boardWidthWithEdges);\r\n              checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n            });\r\n\r\n            if (uncheckedMatchingTiles.length > 1) {\r\n              checkRangeX.sort((a, b) => a - b);\r\n              checkRangeY.sort((a, b) => a - b);\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          // Obstruction in the path. Skip.\r\n          if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n            continue;\r\n          }\r\n\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // Branch out to different segments if necessary.\r\n          // On second segment, only check if on same column.\r\n          if (\r\n            path.length < 3 &&\r\n            !(\r\n              path.length === 2 &&\r\n              !checkRangeX.includes(nextTile.id % boardWidthWithEdges)\r\n            )\r\n          ) {\r\n            if (\r\n              checkRangeY[0] <\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            ) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n              paths.push(newPath);\r\n            }\r\n\r\n            if (\r\n              checkRangeY.at(-1) >\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            ) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n              paths.push(newPath);\r\n            }\r\n          }\r\n\r\n          // Path is going too far away from the range or is nearing the edge\r\n          // of the board.\r\n          if (\r\n            (path.length === 2 &&\r\n              checkRangeX.at(-1) < nextTile.id % boardWidthWithEdges) ||\r\n            nextTile.id % boardWidthWithEdges === boardWidthWithEdges - 1\r\n          ) {\r\n            continue;\r\n          }\r\n\r\n          paths.push(path);\r\n          continue;\r\n        case \"L\":\r\n          nextTile = board[lastTile - 1];\r\n\r\n          // Did we find a path?\r\n          if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n            validMatches.push([tile.id, nextTile.id]);\r\n\r\n            uncheckedMatchingTiles.splice(\r\n              uncheckedMatchingTiles.indexOf(nextTile.id),\r\n              1\r\n            );\r\n\r\n            if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n            // Generate new ranges to check\r\n            uncheckedMatchingTiles.forEach((tile) => {\r\n              checkRangeX.push(tile % boardWidthWithEdges);\r\n              checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n            });\r\n\r\n            if (uncheckedMatchingTiles.length > 1) {\r\n              checkRangeX.sort((a, b) => a - b);\r\n              checkRangeY.sort((a, b) => a - b);\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          // Obstruction in the path. Skip.\r\n          if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n            continue;\r\n          }\r\n\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // Branch out to different segments if necessary.\r\n          // On second segment, only check if on same column.\r\n          if (\r\n            path.length < 3 &&\r\n            !(\r\n              path.length === 2 &&\r\n              !checkRangeX.includes(nextTile.id % boardWidthWithEdges)\r\n            )\r\n          ) {\r\n            if (\r\n              checkRangeY[0] <\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            ) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n              paths.push(newPath);\r\n            }\r\n\r\n            if (\r\n              checkRangeY.at(-1) >\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            ) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n              paths.push(newPath);\r\n            }\r\n          }\r\n\r\n          // Path is going too far away from the range or is nearing the edge\r\n          // of the board.\r\n          if (\r\n            (path.length === 2 &&\r\n              checkRangeX[0] > nextTile.id % boardWidthWithEdges) ||\r\n            nextTile.id % boardWidthWithEdges === 0\r\n          ) {\r\n            continue;\r\n          }\r\n\r\n          paths.push(path);\r\n          continue;\r\n        case \"D\":\r\n          nextTile = board[lastTile + boardWidthWithEdges];\r\n\r\n          // Did we find a path?\r\n          if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n            validMatches.push([tile.id, nextTile.id]);\r\n\r\n            uncheckedMatchingTiles.splice(\r\n              uncheckedMatchingTiles.indexOf(nextTile.id),\r\n              1\r\n            );\r\n\r\n            if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n            // Generate new ranges to check\r\n            uncheckedMatchingTiles.forEach((tile) => {\r\n              checkRangeX.push(tile % boardWidthWithEdges);\r\n              checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n            });\r\n\r\n            if (uncheckedMatchingTiles.length > 1) {\r\n              checkRangeX.sort((a, b) => a - b);\r\n              checkRangeY.sort((a, b) => a - b);\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          // Obstruction in the path. Skip.\r\n          if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n            continue;\r\n          }\r\n\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // Branch out to different segments if necessary.\r\n          // On second segment, only check if on same row.\r\n          if (\r\n            path.length < 3 &&\r\n            !(\r\n              path.length === 2 &&\r\n              !checkRangeY.includes(\r\n                nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n              )\r\n            )\r\n          ) {\r\n            if (checkRangeX[0] < nextTile.id % boardWidthWithEdges) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n              paths.push(newPath);\r\n            }\r\n\r\n            if (checkRangeX.at(-1) > nextTile.id % boardWidthWithEdges) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n              paths.push(newPath);\r\n            }\r\n          }\r\n\r\n          // Path is going too far away from the range or is nearing the edge\r\n          // of the board.\r\n          if (\r\n            (path.length === 2 &&\r\n              checkRangeY.at(-1) <\r\n                nextTile.id - (nextTile.id % boardWidthWithEdges)) ||\r\n            nextTile.id >= boardWidthWithEdges * (boardHeightWithEdges - 1)\r\n          ) {\r\n            continue;\r\n          }\r\n\r\n          paths.push(path);\r\n          continue;\r\n        case \"U\":\r\n          nextTile = board[lastTile - boardWidthWithEdges];\r\n\r\n          // Did we find a path?\r\n          if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n            validMatches.push([tile.id, nextTile.id]);\r\n\r\n            uncheckedMatchingTiles.splice(\r\n              uncheckedMatchingTiles.indexOf(nextTile.id),\r\n              1\r\n            );\r\n\r\n            if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n            // Generate new ranges to check\r\n            uncheckedMatchingTiles.forEach((tile) => {\r\n              checkRangeX.push(tile % boardWidthWithEdges);\r\n              checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n            });\r\n\r\n            if (uncheckedMatchingTiles.length > 1) {\r\n              checkRangeX.sort((a, b) => a - b);\r\n              checkRangeY.sort((a, b) => a - b);\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          // Obstruction in the path. Skip.\r\n          if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n            continue;\r\n          }\r\n\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // Branch out to different segments if necessary.\r\n          // On second segment, only check if on same row.\r\n          if (\r\n            path.length < 3 &&\r\n            !(\r\n              path.length === 2 &&\r\n              !checkRangeY.includes(\r\n                nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n              )\r\n            )\r\n          ) {\r\n            if (checkRangeX[0] < nextTile.id % boardWidthWithEdges) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n              paths.push(newPath);\r\n            }\r\n\r\n            if (checkRangeX.at(-1) > nextTile.id % boardWidthWithEdges) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n              paths.push(newPath);\r\n            }\r\n          }\r\n\r\n          // Path is going too far away from the range or is nearing the edge\r\n          // of the board.\r\n          if (\r\n            (path.length === 2 &&\r\n              checkRangeY[0] >\r\n                nextTile.id - (nextTile.id % boardWidthWithEdges)) ||\r\n            nextTile.id < boardWidthWithEdges\r\n          ) {\r\n            continue;\r\n          }\r\n\r\n          paths.push(path);\r\n          continue;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n  });\r\n\r\n  return validMatches;\r\n}\r\n","import './App.css';\n\nimport Game from './game/Game.js'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Game/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorkerRegistration from \"./serviceWorkerRegistration\";\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorkerRegistration.register();\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}