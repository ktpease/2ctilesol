{"version":3,"sources":["game/PathLogic.js","game/Tile.js","game/PathNode.js","game/Game.js","App.js","reportWebVitals.js","index.js"],"names":["checkAllPossibleMatches","board","boardWidth","boardHeight","boardWidthWithEdges","boardHeightWithEdges","validMatches","forEach","tile","char","inRemovalAnim","uncheckedMatchingTiles","i","id","length","push","console","debug","checkRangeX","checkRangeY","sort","a","b","paths","segment","dir","path","pop","curSegment","at","lastTile","nextTile","includes","splice","indexOf","newPath","map","concat","Tile","props","tileNum","parseInt","isNaN","glyph","className","tileStatusClass","selected","highlighted","hinted","tileColorClass","pointer","fade","onClick","String","fromCodePoint","PathNode","node","nodeClass","index","Game","state","useEmoji","allowDeselect","showMatchingTiles","showAllValidMatches","seed","tiles","selectedTile","tileHistory","hintedTiles","allValidMatches","allValidMatchTiles","pathingTiles","pathingTilesAlt","useAltPathingTiles","horizontalTileMap","verticalTileMap","this","checkEmojiMode","generateBoard","window","navigator","test","userAgent","setState","width","height","allValidTiles","newWidth","newHeight","chardupe","finalSeed","seedrandom","int32","seededRng","tileCharUsed","Array","keys","randValue","Math","floor","x","y","log","generateHorizontalMap","generateVerticalMap","checkAllValidMatches","Set","flat","reduce","tileId","firstTile","secondTile","simplestPath","tileXdelta","tileYdelta","DEBUG_pathsEaten","unshift","checkSimplestPath","slice","newTiles","tile1","tile2","line","filter","t","lastMatch","tileMap","renderTile","_el","reverse","tileobj","handleTileClick","renderHorizontalMap","renderVerticalMap","undoMatch","disabled","React","Component","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.53589a16.chunk.js","sourcesContent":["/**\r\n * Check the simplest (i.e. least amount of segments) nikakudori path between\r\n * two tiles on the provided game board.\r\n *\r\n * This utilizes an iterative depth-first search approach, with special modifications\r\n * to account for the limited amount of line segments.\r\n *\r\n * @param {!number} firstTile The tile index to start from\r\n * @param {!number} secondTile The tile index to end up on\r\n * @param {!{{<id: number, char: number>}}[]} board The tiles\r\n * themselves, which should be (1 + boardWidth + 1) * (1 + boardHeight + 1)\r\n * to account for the edges.\r\n * @param {!number} boardWidth Width of the board, excluding the edges.\r\n * @param {!number} boardHeight Height of the board, excluding the edges.\r\n * @returns {?{{<segment: number[], dir: string>}}[]} An array of line segments showing\r\n * one of the simplest paths. Segments are list of tile indexes in order.\r\n * Dir can be \"U\", \"D\", \"L\", or \"R\".\r\n */\r\nexport function checkSimplestPath(\r\n  firstTile,\r\n  secondTile,\r\n  board,\r\n  boardWidth,\r\n  boardHeight\r\n) {\r\n  if (firstTile === secondTile) return null;\r\n\r\n  const boardWidthWithEdges = boardWidth + 2,\r\n    boardHeightWithEdges = boardHeight + 2;\r\n\r\n  let paths = [],\r\n    simplestPath = null;\r\n\r\n  const tileXdelta =\r\n    (secondTile % boardWidthWithEdges) - (firstTile % boardWidthWithEdges);\r\n  const tileYdelta =\r\n    (secondTile -\r\n      (secondTile % boardWidthWithEdges) -\r\n      (firstTile - (firstTile % boardWidthWithEdges))) /\r\n    boardWidthWithEdges;\r\n\r\n  let DEBUG_pathsEaten = 0;\r\n  console.debug(`tile X delta: ${tileXdelta}`);\r\n  console.debug(`tile Y delta: ${tileYdelta}`);\r\n\r\n  // Do not check opposite direction if in the same row or column.\r\n\r\n  if (tileYdelta !== 0 || tileXdelta > 0) {\r\n    paths.push([{ segment: [firstTile], dir: \"R\" }]);\r\n  }\r\n\r\n  if (tileYdelta !== 0 || tileXdelta < 0) {\r\n    if (tileXdelta < 0) paths.push([{ segment: [firstTile], dir: \"L\" }]);\r\n    else paths.unshift([{ segment: [firstTile], dir: \"L\" }]);\r\n  }\r\n\r\n  if (tileXdelta !== 0 || tileYdelta > 0) {\r\n    if (tileYdelta >= 0) paths.push([{ segment: [firstTile], dir: \"D\" }]);\r\n    else paths.unshift([{ segment: [firstTile], dir: \"D\" }]);\r\n  }\r\n\r\n  if (tileXdelta !== 0 || tileYdelta < 0) {\r\n    if (tileYdelta < 0) paths.push([{ segment: [firstTile], dir: \"U\" }]);\r\n    else paths.push([{ segment: [firstTile], dir: \"U\" }]);\r\n  }\r\n\r\n  for (let i = 0; i < paths.length; i++) {\r\n    console.debug(paths[i]);\r\n  }\r\n\r\n  while (paths.length > 0) {\r\n    const path = paths.pop();\r\n    DEBUG_pathsEaten++;\r\n\r\n    console.debug(\r\n      `Checking path: ${path.at(-1).segment} | ${path.at(-1).dir} | length: ${\r\n        path.length\r\n      } | queue: ${paths.length}`\r\n    );\r\n\r\n    // If we already found a three-line path, we shouldn't look for more\r\n    // three-line paths.\r\n    if (simplestPath !== null && path.length === 3) {\r\n      console.debug(\"- Looking for less-line paths\");\r\n      continue;\r\n    }\r\n\r\n    const curSegment = path.at(-1);\r\n    const lastTile = curSegment.segment.at(-1);\r\n    let nextTile;\r\n\r\n    switch (curSegment.dir) {\r\n      case \"R\":\r\n        nextTile = board[lastTile + 1];\r\n\r\n        // We found the path, or a simpler one!\r\n        if (nextTile.id === secondTile) {\r\n          console.debug(\"- Found simplest path?\");\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // If it is a one-line or two-line path, it's one of the\r\n          // absolute shortest paths. We're done!\r\n          if (path.length < 3) {\r\n            console.debug(\"-- It is!\");\r\n            console.debug(`${DEBUG_pathsEaten} PATHS EATEN`);\r\n            return path;\r\n          }\r\n\r\n          console.debug(\"-- Maybe?\");\r\n          simplestPath = path;\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n          console.debug(\"- Obstruction in path\");\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // On first and second segment, check U if second tile is above and\r\n        // check D if the second tile is below.\r\n        // On second segment, only check if on same column.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            secondTile % boardWidthWithEdges !==\r\n              nextTile.id % boardWidthWithEdges\r\n          )\r\n        ) {\r\n          if (\r\n            secondTile - (secondTile % boardWidthWithEdges) <\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            console.debug(\"- Add path U\");\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n            if (tileYdelta < 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          } else if (\r\n            secondTile - (secondTile % boardWidthWithEdges) >\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            console.debug(\"- Add path D\");\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n            if (tileYdelta >= 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          }\r\n        }\r\n\r\n        if (\r\n          (path.length === 2 &&\r\n            secondTile % boardWidthWithEdges <\r\n              nextTile.id % boardWidthWithEdges) ||\r\n          nextTile.id % boardWidthWithEdges === boardWidthWithEdges - 1\r\n        ) {\r\n          console.debug(\"- Do not proceed further, will miss\");\r\n          continue;\r\n        }\r\n\r\n        console.debug(\"- Continuing path\");\r\n        if (tileXdelta >= 0) paths.push(path);\r\n        else paths.unshift(path);\r\n        continue;\r\n      case \"L\":\r\n        nextTile = board[lastTile - 1];\r\n\r\n        // We found the path, or a simpler one!\r\n        if (nextTile.id === secondTile) {\r\n          console.debug(\"- Found simplest path\");\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // If it is a one-line or two-line path, it's one of the\r\n          // absolute shortest paths. We're done!\r\n          if (path.length < 3) {\r\n            console.debug(\"-- It is!\");\r\n            console.debug(`${DEBUG_pathsEaten} PATHS EATEN`);\r\n            return path;\r\n          }\r\n\r\n          console.debug(\"-- Maybe?\");\r\n          simplestPath = path;\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n          console.debug(\"- Obstruction in path\");\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // On first and second segment, check U if second tile is above and\r\n        // check D if the second tile is below.\r\n        // On second segment, only check if on same column.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            secondTile % boardWidthWithEdges !==\r\n              nextTile.id % boardWidthWithEdges\r\n          )\r\n        ) {\r\n          if (\r\n            secondTile - (secondTile % boardWidthWithEdges) <\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            console.debug(\"- Add path U\");\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n            if (tileYdelta < 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          } else if (\r\n            secondTile - (secondTile % boardWidthWithEdges) >\r\n            nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          ) {\r\n            console.debug(\"- Add path D\");\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n            if (tileYdelta >= 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          }\r\n        }\r\n\r\n        if (\r\n          (path.length === 2 &&\r\n            secondTile % boardWidthWithEdges >\r\n              nextTile.id % boardWidthWithEdges) ||\r\n          nextTile.id % boardWidthWithEdges === 0\r\n        ) {\r\n          console.debug(\"- Do not proceed further, will miss\");\r\n          continue;\r\n        }\r\n\r\n        console.debug(\"- Continuing path\");\r\n        if (tileXdelta < 0) paths.push(path);\r\n        else paths.unshift(path);\r\n        continue;\r\n      case \"D\":\r\n        nextTile = board[lastTile + boardWidthWithEdges];\r\n\r\n        // We found the path, or a simpler one!\r\n        if (nextTile.id === secondTile) {\r\n          console.debug(\"- Found simplest path\");\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // If it is a one-line or two-line path, it's one of the\r\n          // absolute shortest paths. We're done!\r\n          if (path.length < 3) {\r\n            console.debug(\"-- It is!\");\r\n            console.debug(`${DEBUG_pathsEaten} PATHS EATEN`);\r\n            return path;\r\n          }\r\n\r\n          console.debug(\"-- Maybe?\");\r\n          simplestPath = path;\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n          console.debug(\"- Obstruction in path\");\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // On first and second segment, check L if second tile is left and\r\n        // check R if the second tile is right.\r\n        // On second segment, only check if on same row.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            secondTile - (secondTile % boardWidthWithEdges) !==\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          )\r\n        ) {\r\n          if (\r\n            secondTile % boardWidthWithEdges <\r\n            nextTile.id % boardWidthWithEdges\r\n          ) {\r\n            console.debug(\"- Add path L\");\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n            if (tileXdelta < 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          } else if (\r\n            secondTile % boardWidthWithEdges >\r\n            nextTile.id % boardWidthWithEdges\r\n          ) {\r\n            console.debug(\"- Add path R\");\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n            if (tileXdelta >= 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          }\r\n        }\r\n\r\n        if (\r\n          (path.length === 2 &&\r\n            secondTile - (secondTile % boardWidthWithEdges) <\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)) ||\r\n          nextTile.id >= boardWidthWithEdges * (boardHeightWithEdges - 1)\r\n        ) {\r\n          console.debug(\"- Do not proceed further, will miss\");\r\n          continue;\r\n        }\r\n\r\n        console.debug(\"- Continuing path\");\r\n        if (tileYdelta >= 0) paths.push(path);\r\n        else paths.unshift(path);\r\n        continue;\r\n      case \"U\":\r\n        nextTile = board[lastTile - boardWidthWithEdges];\r\n\r\n        // We found the path, or a simpler one!\r\n        if (nextTile.id === secondTile) {\r\n          console.debug(\"- Found simplest path\");\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // If it is a one-line or two-line path, it's one of the\r\n          // absolute shortest paths. We're done!\r\n          if (path.length < 3) {\r\n            console.debug(\"-- It is!\");\r\n            console.debug(`${DEBUG_pathsEaten} PATHS EATEN`);\r\n            return path;\r\n          }\r\n\r\n          console.debug(\"-- Maybe?\");\r\n          simplestPath = path;\r\n          continue;\r\n        }\r\n\r\n        // Obstruction in the path. Skip.\r\n        if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n          console.debug(\"- Obstruction in path\");\r\n          continue;\r\n        }\r\n\r\n        curSegment.segment.push(nextTile.id);\r\n\r\n        // On first and second segment, check L if second tile is left and\r\n        // check R if the second tile is right.\r\n        // On second segment, only check if on same row.\r\n        if (\r\n          path.length < 3 &&\r\n          !(\r\n            path.length === 2 &&\r\n            secondTile - (secondTile % boardWidthWithEdges) !==\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n          )\r\n        ) {\r\n          if (\r\n            secondTile % boardWidthWithEdges <\r\n            nextTile.id % boardWidthWithEdges\r\n          ) {\r\n            console.debug(\"- Add path L\");\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n            if (tileXdelta < 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          } else if (\r\n            secondTile % boardWidthWithEdges >\r\n            nextTile.id % boardWidthWithEdges\r\n          ) {\r\n            console.debug(\"- Add path R\");\r\n            const newPath = path.map((i) => ({\r\n              segment: [].concat(i.segment),\r\n              dir: i.dir,\r\n            }));\r\n            newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n            if (tileXdelta >= 0) paths.push(newPath);\r\n            else paths.unshift(newPath);\r\n          }\r\n        }\r\n\r\n        if (\r\n          (path.length === 2 &&\r\n            secondTile - (secondTile % boardWidthWithEdges) >\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)) ||\r\n          nextTile.id < boardWidthWithEdges\r\n        ) {\r\n          console.debug(\"- Do not proceed further, will miss\");\r\n          continue;\r\n        }\r\n\r\n        console.debug(\"- Continuing path\");\r\n        if (tileYdelta < 0) paths.push(path);\r\n        else paths.unshift(path);\r\n        continue;\r\n      default:\r\n        break;\r\n    }\r\n  }\r\n\r\n  console.debug(`${DEBUG_pathsEaten} PATHS EATEN`);\r\n  return simplestPath;\r\n}\r\n\r\nexport function checkAllPossibleMatches(board, boardWidth, boardHeight) {\r\n  const boardWidthWithEdges = boardWidth + 2,\r\n    boardHeightWithEdges = boardHeight + 2;\r\n\r\n  let validMatches = [];\r\n\r\n  // Throw out a path for each valid tile.\r\n  board.forEach((tile) => {\r\n    if (tile.char === null || tile.inRemovalAnim === true) return;\r\n\r\n    // Check each tile for matches against later tiles. We've already checked\r\n    // against earlier tiles in earlier checks.\r\n    let uncheckedMatchingTiles = [];\r\n\r\n    for (let i = tile.id + 1; i < board.length; i++) {\r\n      if (board[i].char === tile.char && board[i].inRemovalAnim === false) {\r\n        uncheckedMatchingTiles.push(i);\r\n      }\r\n    }\r\n\r\n    if (uncheckedMatchingTiles.length === 0) return;\r\n\r\n    console.debug(\r\n      `Checking tile ${tile.id} with tiles ${uncheckedMatchingTiles}`\r\n    );\r\n\r\n    // Get the X and Y ranges to check. This prevents the pathing algorithm\r\n    // from exploring areas it doesn't need to.\r\n    let checkRangeX = [],\r\n      checkRangeY = [];\r\n\r\n    uncheckedMatchingTiles.forEach((tile) => {\r\n      checkRangeX.push(tile % boardWidthWithEdges);\r\n      checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n    });\r\n\r\n    if (uncheckedMatchingTiles.length > 1) {\r\n      checkRangeX.sort((a, b) => a - b);\r\n      checkRangeY.sort((a, b) => a - b);\r\n    }\r\n\r\n    // Starting paths\r\n    let paths = [];\r\n\r\n    paths.push([{ segment: [tile.id], dir: \"R\" }]);\r\n    paths.push([{ segment: [tile.id], dir: \"L\" }]);\r\n    paths.push([{ segment: [tile.id], dir: \"U\" }]);\r\n    paths.push([{ segment: [tile.id], dir: \"D\" }]);\r\n\r\n    while (paths.length > 0) {\r\n      const path = paths.pop();\r\n\r\n      const curSegment = path.at(-1);\r\n      const lastTile = curSegment.segment.at(-1);\r\n      let nextTile;\r\n\r\n      switch (curSegment.dir) {\r\n        case \"R\":\r\n          nextTile = board[lastTile + 1];\r\n\r\n          // Did we find a path?\r\n          if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n            validMatches.push([tile.id, nextTile.id]);\r\n\r\n            uncheckedMatchingTiles.splice(\r\n              uncheckedMatchingTiles.indexOf(nextTile.id),\r\n              1\r\n            );\r\n\r\n            if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n            // Generate new ranges to check\r\n            uncheckedMatchingTiles.forEach((tile) => {\r\n              checkRangeX.push(tile % boardWidthWithEdges);\r\n              checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n            });\r\n\r\n            if (uncheckedMatchingTiles.length > 1) {\r\n              checkRangeX.sort((a, b) => a - b);\r\n              checkRangeY.sort((a, b) => a - b);\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          // Obstruction in the path. Skip.\r\n          if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n            continue;\r\n          }\r\n\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // Branch out to different segments if necessary.\r\n          // On second segment, only check if on same column.\r\n          if (\r\n            path.length < 3 &&\r\n            !(\r\n              path.length === 2 &&\r\n              !checkRangeX.includes(nextTile.id % boardWidthWithEdges)\r\n            )\r\n          ) {\r\n            if (\r\n              checkRangeY[0] <\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            ) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n              paths.push(newPath);\r\n            } else if (\r\n              checkRangeY.at(-1) >\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            ) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n              paths.push(newPath);\r\n            }\r\n          }\r\n\r\n          if (\r\n            (path.length === 2 &&\r\n              checkRangeX.at(-1) < nextTile.id % boardWidthWithEdges) ||\r\n            nextTile.id % boardWidthWithEdges === boardWidthWithEdges - 1\r\n          ) {\r\n            continue;\r\n          }\r\n\r\n          paths.push(path);\r\n          continue;\r\n        case \"L\":\r\n          nextTile = board[lastTile - 1];\r\n\r\n          // Did we find a path?\r\n          if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n            validMatches.push([tile.id, nextTile.id]);\r\n\r\n            uncheckedMatchingTiles.splice(\r\n              uncheckedMatchingTiles.indexOf(nextTile.id),\r\n              1\r\n            );\r\n\r\n            if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n            // Generate new ranges to check\r\n            uncheckedMatchingTiles.forEach((tile) => {\r\n              checkRangeX.push(tile % boardWidthWithEdges);\r\n              checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n            });\r\n\r\n            if (uncheckedMatchingTiles.length > 1) {\r\n              checkRangeX.sort((a, b) => a - b);\r\n              checkRangeY.sort((a, b) => a - b);\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          // Obstruction in the path. Skip.\r\n          if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n            continue;\r\n          }\r\n\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // Branch out to different segments if necessary.\r\n          // On second segment, only check if on same column.\r\n          if (\r\n            path.length < 3 &&\r\n            !(\r\n              path.length === 2 &&\r\n              !checkRangeX.includes(nextTile.id % boardWidthWithEdges)\r\n            )\r\n          ) {\r\n            if (\r\n              checkRangeY[0] <\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            ) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"U\" });\r\n              paths.push(newPath);\r\n            } else if (\r\n              checkRangeY.at(-1) >\r\n              nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n            ) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"D\" });\r\n              paths.push(newPath);\r\n            }\r\n          }\r\n\r\n          if (\r\n            (path.length === 2 &&\r\n              checkRangeX[0] > nextTile.id % boardWidthWithEdges) ||\r\n            nextTile.id % boardWidthWithEdges === 0\r\n          ) {\r\n            continue;\r\n          }\r\n\r\n          paths.push(path);\r\n          continue;\r\n        case \"D\":\r\n          nextTile = board[lastTile + boardWidthWithEdges];\r\n\r\n          // Did we find a path?\r\n          if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n            validMatches.push([tile.id, nextTile.id]);\r\n\r\n            uncheckedMatchingTiles.splice(\r\n              uncheckedMatchingTiles.indexOf(nextTile.id),\r\n              1\r\n            );\r\n\r\n            if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n            // Generate new ranges to check\r\n            uncheckedMatchingTiles.forEach((tile) => {\r\n              checkRangeX.push(tile % boardWidthWithEdges);\r\n              checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n            });\r\n\r\n            if (uncheckedMatchingTiles.length > 1) {\r\n              checkRangeX.sort((a, b) => a - b);\r\n              checkRangeY.sort((a, b) => a - b);\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          // Obstruction in the path. Skip.\r\n          if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n            continue;\r\n          }\r\n\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // Branch out to different segments if necessary.\r\n          // On second segment, only check if on same row.\r\n          if (\r\n            path.length < 3 &&\r\n            !(\r\n              path.length === 2 &&\r\n              !checkRangeY.includes(\r\n                nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n              )\r\n            )\r\n          ) {\r\n            if (checkRangeX[0] < nextTile.id % boardWidthWithEdges) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n              paths.push(newPath);\r\n            } else if (checkRangeX.at(-1) > nextTile.id % boardWidthWithEdges) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n              paths.push(newPath);\r\n            }\r\n          }\r\n\r\n          if (\r\n            (path.length === 2 &&\r\n              checkRangeY.at(-1) <\r\n                nextTile.id - (nextTile.id % boardWidthWithEdges)) ||\r\n            nextTile.id >= boardWidthWithEdges * (boardHeightWithEdges - 1)\r\n          ) {\r\n            continue;\r\n          }\r\n\r\n          paths.push(path);\r\n          continue;\r\n        case \"U\":\r\n          nextTile = board[lastTile - boardWidthWithEdges];\r\n\r\n          // Did we find a path?\r\n          if (uncheckedMatchingTiles.includes(nextTile.id)) {\r\n            validMatches.push([tile.id, nextTile.id]);\r\n\r\n            uncheckedMatchingTiles.splice(\r\n              uncheckedMatchingTiles.indexOf(nextTile.id),\r\n              1\r\n            );\r\n\r\n            if (uncheckedMatchingTiles.length === 0) break;\r\n\r\n            // Generate new ranges to check\r\n            uncheckedMatchingTiles.forEach((tile) => {\r\n              checkRangeX.push(tile % boardWidthWithEdges);\r\n              checkRangeY.push(tile - (tile % boardWidthWithEdges));\r\n            });\r\n\r\n            if (uncheckedMatchingTiles.length > 1) {\r\n              checkRangeX.sort((a, b) => a - b);\r\n              checkRangeY.sort((a, b) => a - b);\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          // Obstruction in the path. Skip.\r\n          if (nextTile.char !== null && nextTile.inRemovalAnim !== true) {\r\n            continue;\r\n          }\r\n\r\n          curSegment.segment.push(nextTile.id);\r\n\r\n          // Branch out to different segments if necessary.\r\n          // On second segment, only check if on same row.\r\n          if (\r\n            path.length < 3 &&\r\n            !(\r\n              path.length === 2 &&\r\n              !checkRangeY.includes(\r\n                nextTile.id - (nextTile.id % boardWidthWithEdges)\r\n              )\r\n            )\r\n          ) {\r\n            if (checkRangeX[0] < nextTile.id % boardWidthWithEdges) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"L\" });\r\n              paths.push(newPath);\r\n            } else if (checkRangeX.at(-1) > nextTile.id % boardWidthWithEdges) {\r\n              const newPath = path.map((i) => ({\r\n                segment: [].concat(i.segment),\r\n                dir: i.dir,\r\n              }));\r\n              newPath.push({ segment: [nextTile.id], dir: \"R\" });\r\n              paths.push(newPath);\r\n            }\r\n          }\r\n\r\n          if (\r\n            (path.length === 2 &&\r\n              checkRangeY[0] >\r\n                nextTile.id - (nextTile.id % boardWidthWithEdges)) ||\r\n            nextTile.id < boardWidthWithEdges\r\n          ) {\r\n            continue;\r\n          }\r\n\r\n          paths.push(path);\r\n          continue;\r\n        default:\r\n          break;\r\n      }\r\n    }\r\n  });\r\n\r\n  return validMatches;\r\n}\r\n","export default function Tile(props) {\r\n  // Number between 0-42, corresponding to the Mahjong Tiles Unicode block.\r\n  const tileNum = parseInt(props.tile, 10);\r\n\r\n  // Check if tile is valid.\r\n  if (isNaN(tileNum) || tileNum < 0 || tileNum >= 43) {\r\n    return props.glyph ? (\r\n      <span className=\"game-tile-glyph game-tile-empty\">&#x1F02B;&#xFE0E;</span>\r\n    ) : (\r\n      <span className=\"game-tile-emoji game-tile-empty\">&#x1F02B;</span>\r\n    );\r\n  }\r\n\r\n  let tileStatusClass = \"\";\r\n\r\n  if (props.selected) tileStatusClass = \"game-tile-selected\";\r\n  else if (props.highlighted) tileStatusClass = \"game-tile-highlighted\";\r\n  else if (props.hinted) tileStatusClass = \"game-tile-hinted\";\r\n\r\n  if (props.glyph) {\r\n    // If the font uses the glyph variant, give them a colorized border.\r\n    let tileColorClass = \"\";\r\n\r\n    if ((tileNum >= 7 && tileNum <= 15) || tileNum === 4) {\r\n      tileColorClass = \"game-tile-glyph-red\";\r\n    } else if ((tileNum >= 16 && tileNum <= 24) || tileNum === 5) {\r\n      tileColorClass = \"game-tile-glyph-green\";\r\n    } else if ((tileNum >= 25 && tileNum <= 33) || tileNum === 6) {\r\n      tileColorClass = \"game-tile-glyph-blue\";\r\n    } else if (tileNum >= 34 && tileNum <= 37) {\r\n      tileColorClass = \"game-tile-glyph-flowers\";\r\n    } else if (tileNum >= 38 && tileNum <= 41) {\r\n      tileColorClass = \"game-tile-glyph-seasons\";\r\n    }\r\n\r\n    return (\r\n      <span\r\n        className={`game-tile-glyph ${tileColorClass} ${tileStatusClass} ${\r\n          props.pointer ? \"game-tile-pointer\" : \"\"\r\n        } ${props.fade ? \"game-tile-anim-fadeout\" : \"\"}`}\r\n        onClick={props.onClick}\r\n      >\r\n        {String.fromCodePoint(0x1f000 + tileNum)}&#xFE0E;\r\n      </span>\r\n    );\r\n  } else {\r\n    return (\r\n      <span\r\n        className={`game-tile-emoji ${tileStatusClass} ${\r\n          props.pointer ? \"game-tile-pointer\" : \"\"\r\n        } ${props.fade ? \"game-tile-anim-fadeout\" : \"\"}`}\r\n        onClick={props.onClick}\r\n      >\r\n        {String.fromCodePoint(0x1f000 + tileNum)}\r\n      </span>\r\n    );\r\n  }\r\n}\r\n","export default function PathNode(props) {\r\n  if (props.node && props.node.length > 0) {\r\n    let nodeClass = \"\";\r\n\r\n    props.node.forEach((dir, index) => {\r\n      if (index === 0) nodeClass = \"game-path-\";\r\n      nodeClass = nodeClass.concat(dir);\r\n    });\r\n\r\n    return <span className={`game-path ${nodeClass} game-path-anim-fadeout`} />;\r\n  }\r\n\r\n  return null;\r\n}\r\n","import React from \"react\";\r\nimport seedrandom from \"seedrandom\";\r\n\r\nimport { checkSimplestPath, checkAllPossibleMatches } from \"./PathLogic.js\";\r\n\r\nimport Tile from \"./Tile.js\";\r\nimport PathNode from \"./PathNode.js\";\r\n\r\nimport \"./Game.css\";\r\n\r\nexport default class Game extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this.state = {\r\n      // Options\r\n      useEmoji: false,\r\n      allowDeselect: true,\r\n      showMatchingTiles: true,\r\n      showAllValidMatches: true,\r\n      // Board Generation Options\r\n      boardWidth: 17,\r\n      boardHeight: 8,\r\n      seed: 1,\r\n      // Tile State\r\n      tiles: [],\r\n      selectedTile: null,\r\n      // Tile History\r\n      tileHistory: [],\r\n      // Tile Hinting\r\n      hintedTiles: [],\r\n      allValidMatches: [],\r\n      allValidMatchTiles: [],\r\n      // Pathing Maps\r\n      pathingTiles: [],\r\n      pathingTilesAlt: [],\r\n      useAltPathingTiles: false,\r\n      // Tile Display Maps\r\n      horizontalTileMap: [],\r\n      verticalTileMap: [],\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.checkEmojiMode();\r\n    this.generateBoard();\r\n  }\r\n\r\n  checkEmojiMode() {\r\n    // Currently, all majong tiles are Non-RGI with the exception of Red Dragon,\r\n    // and the only system font that supports all of these tiles as emojis is the\r\n    // Segoe UI Emoji family, included in Windows 10+.\r\n    //\r\n    // It is unlikely that future Unicode Emoji specifications will support\r\n    // all tiles as RGI, and I'm unsure if other system font providers will\r\n    // support them. So for now, we'll just assume that only desktop Windows 10+\r\n    // can run the emoji mode.\r\n    //\r\n    // If any other system or custom font providers begin supporting this, just\r\n    // please make sure they're front-facing (looking at you, Noto Emoji).\r\n\r\n    // If we don't care that it breaks previous Windows versions, we can just\r\n    // use the is-windows package. But for compatibility, we'll just check the\r\n    // browser's user agent string.\r\n    //\r\n    // Conveniently, Windows 10 and up have double-digit version numbers!\r\n    if (\r\n      window.navigator &&\r\n      /Windows NT \\d{2}/.test(window.navigator.userAgent)\r\n    ) {\r\n      this.setState({ useEmoji: true });\r\n    }\r\n  }\r\n\r\n  generateBoard(seed, width, height) {\r\n    const tiles = [],\r\n      allValidTiles = [];\r\n\r\n    const newWidth = width ? width : this.state.boardWidth,\r\n      newHeight = height ? height : this.state.boardHeight;\r\n\r\n    let id = 0,\r\n      char = -1,\r\n      chardupe = -1;\r\n\r\n    // Determine if we need to generate a random seed\r\n    // or use a pre-determined one from the seed argument.\r\n    // This will be used in both tile selection and board shuffling.\r\n    const finalSeed = isNaN(parseInt(seed, 10))\r\n      ? seedrandom().int32() >>> 0\r\n      : parseInt(seed, 10) >>> 0;\r\n\r\n    const seededRng = seedrandom(finalSeed);\r\n\r\n    // Generate which tiles are used. This is done by listing all\r\n    // possible tiles (without duplicates), then shuffling with\r\n    // a simple Fisher-Yates shuffle.\r\n    let tileCharUsed = [...Array(34).keys()],\r\n      randValue = 0;\r\n\r\n    // Chrome for Android has a bug where it'll not respect VS15/U+FE0E and\r\n    // always render the Red Dragon tile as emoji. Until it is fixed, replace\r\n    // the Red Dragon with the unused Joker tile.\r\n    if (\r\n      window.navigator &&\r\n      window.navigator.userAgent.includes(\"Chrome\") &&\r\n      window.navigator.userAgent.includes(\"Mobile\")\r\n    ) {\r\n      tileCharUsed[4] = 42;\r\n    }\r\n\r\n    for (let i = tileCharUsed.length - 1; i > 0; i--) {\r\n      randValue = Math.floor(seededRng() * (i + 1));\r\n\r\n      char = tileCharUsed[i];\r\n      tileCharUsed[i] = tileCharUsed[randValue];\r\n      tileCharUsed[randValue] = char;\r\n    }\r\n\r\n    // Top outer edge.\r\n    for (let x = 0; x < newWidth + 2; x++)\r\n      id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n\r\n    // Generate the initial unshuffled layout of tiles.\r\n    for (let y = 0; y < newHeight; y++) {\r\n      // Left outer edge.\r\n      id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n\r\n      for (let x = 0; x < newWidth; x++) {\r\n        if ((chardupe = (chardupe + 1) % 4) === 0) {\r\n          char = (char + 1) % tileCharUsed.length;\r\n        }\r\n\r\n        allValidTiles.push(id);\r\n        id = tiles.push({\r\n          id: id,\r\n          char: tileCharUsed[char],\r\n          inRemovalAnim: false,\r\n        });\r\n      }\r\n\r\n      // Right outer edge.\r\n      id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n    }\r\n\r\n    // Bottom outer edge.\r\n    for (let x = 0; x < newWidth + 2; x++)\r\n      id = tiles.push({ id: id, char: null, inRemovalAnim: false });\r\n\r\n    // Shuffle the board using a simple Fisher-Yates shuffle.\r\n    for (let i = allValidTiles.length - 1; i > 0; i--) {\r\n      randValue = Math.floor(seededRng() * (i + 1));\r\n\r\n      char = tiles[allValidTiles[i]].char;\r\n      tiles[allValidTiles[i]].char = tiles[allValidTiles[randValue]].char;\r\n      tiles[allValidTiles[randValue]].char = char;\r\n    }\r\n\r\n    console.log(`Game board seed is ${finalSeed}`);\r\n\r\n    this.setState(\r\n      {\r\n        tiles: tiles,\r\n        boardWidth: newWidth,\r\n        boardHeight: newHeight,\r\n        seed: finalSeed,\r\n        selectedTile: null,\r\n        tileHistory: [],\r\n        hintedTiles: [],\r\n        allValidMatches: [],\r\n        pathingTiles: [],\r\n        pathingTilesAlt: [],\r\n      },\r\n      () => {\r\n        this.generateHorizontalMap();\r\n        this.generateVerticalMap();\r\n\r\n        this.checkAllValidMatches();\r\n      }\r\n    );\r\n  }\r\n\r\n  checkAllValidMatches() {\r\n    this.setState(\r\n      {\r\n        allValidMatches: checkAllPossibleMatches(\r\n          this.state.tiles,\r\n          this.state.boardWidth,\r\n          this.state.boardHeight\r\n        ),\r\n      },\r\n      () => {\r\n        this.setState({\r\n          allValidMatchTiles: [...new Set(this.state.allValidMatches.flat())],\r\n        });\r\n        if (this.state.showAllValidMatches === true) {\r\n          console.log(\r\n            this.state.allValidMatches.reduce(\r\n              (a, b) =>\r\n                a.concat(\r\n                  `[${(b[0] % (this.state.boardWidth + 2)) - 1},${\r\n                    (b[0] -\r\n                      (b[0] % (this.state.boardWidth + 2)) -\r\n                      (this.state.boardWidth + 2)) /\r\n                    (this.state.boardWidth + 2)\r\n                  } <-> ${(b[1] % (this.state.boardWidth + 2)) - 1},${\r\n                    (b[1] -\r\n                      (b[1] % (this.state.boardWidth + 2)) -\r\n                      (this.state.boardWidth + 2)) /\r\n                    (this.state.boardWidth + 2)\r\n                  }] `\r\n                ),\r\n              \"\"\r\n            )\r\n          );\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  handleTileClick(tileId) {\r\n    // Don't click empty or tiles being removed.\r\n    if (\r\n      this.state.tiles[tileId].char === null ||\r\n      this.state.tiles[tileId].inRemovalAnim === true\r\n    ) {\r\n      return;\r\n    }\r\n\r\n    // Clicking the same tile either de-selects the tile or does nothing.\r\n    if (this.state.selectedTile === tileId) {\r\n      if (this.state.allowDeselect === true) {\r\n        this.setState({ selectedTile: null, hintedTiles: [] });\r\n        console.debug(`Unclicked ${tileId}`);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    console.debug(`Clicked ${tileId}`);\r\n\r\n    // If selecting a second tile, check to make sure it matches the first,\r\n    // then check the pathing to see if it's valid, then clear valid matches.\r\n    if (\r\n      this.state.selectedTile !== null &&\r\n      this.state.tiles[tileId].char ===\r\n        this.state.tiles[this.state.selectedTile].char\r\n    ) {\r\n      const path = checkSimplestPath(\r\n        tileId,\r\n        this.state.selectedTile,\r\n        this.state.tiles.slice(),\r\n        this.state.boardWidth,\r\n        this.state.boardHeight\r\n      );\r\n\r\n      if (path !== null) {\r\n        console.debug(path);\r\n\r\n        // Create an updated board, first by removing the tiles in its\r\n        // fadeout animation, then putting the match in that same animation.\r\n        const newTiles = this.state.tiles.slice();\r\n\r\n        newTiles.forEach((tile) => {\r\n          if (tile.inRemovalAnim === true) {\r\n            tile.inRemovalAnim = false;\r\n            tile.char = null;\r\n          }\r\n        });\r\n\r\n        newTiles[tileId].inRemovalAnim = true;\r\n        newTiles[this.state.selectedTile].inRemovalAnim = true;\r\n\r\n        const tileHistory = this.state.tileHistory.slice();\r\n\r\n        tileHistory.push({\r\n          char: this.state.tiles[tileId].char,\r\n          tile1: tileId,\r\n          tile2: this.state.selectedTile,\r\n        });\r\n\r\n        // Generate the pathing tiles for display.\r\n        const pathingTiles = this.state.tiles.map(() => []);\r\n\r\n        path.forEach((line) => {\r\n          line.segment.forEach((node) => {\r\n            pathingTiles[node].push(line.dir);\r\n          });\r\n        });\r\n\r\n        pathingTiles[this.state.selectedTile].push(\"-start\");\r\n        pathingTiles[tileId].push(\"-end\");\r\n\r\n        this.setState(\r\n          {\r\n            tiles: newTiles,\r\n            selectedTile: null,\r\n            tileHistory: tileHistory,\r\n            hintedTiles: [],\r\n          },\r\n          () => {\r\n            this.checkAllValidMatches();\r\n          }\r\n        );\r\n\r\n        // Switch between primary and alternate pathing maps. This is used\r\n        // as a makeshift solution to consecutive matches using the same tile\r\n        // path, as the CSS animation doesn't get reset.\r\n        if (this.state.useAltPathingTiles === true)\r\n          this.setState({\r\n            pathingTiles: this.state.tiles.map(() => []),\r\n            pathingTilesAlt: pathingTiles,\r\n            useAltPathingTiles: false,\r\n          });\r\n        else\r\n          this.setState({\r\n            pathingTiles: pathingTiles,\r\n            pathingTilesAlt: this.state.tiles.map(() => []),\r\n            useAltPathingTiles: true,\r\n          });\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Update the hinting system, if it's enabled.\r\n    if (this.state.showMatchingTiles === true) {\r\n      const hintedTiles = this.state.tiles.filter(\r\n        (t) => t.char === this.state.tiles[tileId].char\r\n      );\r\n\r\n      this.setState({ hintedTiles: hintedTiles, selectedTile: tileId });\r\n      return;\r\n    }\r\n\r\n    this.setState({ selectedTile: tileId });\r\n  }\r\n\r\n  undoMatch() {\r\n    if (this.state.tileHistory.length > 0) {\r\n      const newTiles = this.state.tiles.slice();\r\n      const lastMatch = this.state.tileHistory.pop();\r\n\r\n      newTiles[lastMatch.tile1].char = lastMatch.char;\r\n      newTiles[lastMatch.tile1].inRemovalAnim = false;\r\n\r\n      newTiles[lastMatch.tile2].char = lastMatch.char;\r\n      newTiles[lastMatch.tile2].inRemovalAnim = false;\r\n\r\n      this.setState(\r\n        {\r\n          tiles: newTiles,\r\n          hintedTiles: [],\r\n          pathingTiles: [],\r\n          pathingTilesAlt: [],\r\n          selectedTile: null,\r\n        },\r\n        () => {\r\n          this.checkAllValidMatches();\r\n        }\r\n      );\r\n    }\r\n  }\r\n\r\n  generateHorizontalMap() {\r\n    const tileMap = [];\r\n\r\n    // Standard horizontal board. Used for landscape orientation.\r\n    for (let y = 0; y < this.state.boardHeight + 2; y++) {\r\n      tileMap[y] = this.state.tiles.slice(\r\n        y * (this.state.boardWidth + 2),\r\n        (y + 1) * (this.state.boardWidth + 2)\r\n      );\r\n    }\r\n\r\n    this.setState({ horizontalTileMap: tileMap });\r\n  }\r\n\r\n  renderHorizontalMap() {\r\n    const tileMap = [];\r\n\r\n    if (typeof this.state.horizontalTileMap === \"undefined\") {\r\n      return;\r\n    }\r\n\r\n    for (let y = 0; y < this.state.horizontalTileMap.length; y++) {\r\n      tileMap[y] = (\r\n        <div key={\"board-hori-row\" + y}>\r\n          {this.state.horizontalTileMap[y].map((i) => this.renderTile(i))}\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return tileMap;\r\n  }\r\n\r\n  generateVerticalMap() {\r\n    const tileMap = [];\r\n\r\n    // Rotated vertical board. Used for portrait orientation.\r\n    for (let x = 0; x < this.state.boardWidth + 2; x++) {\r\n      tileMap[x] = this.state.tiles\r\n        .filter((_el, index) => index % (this.state.boardWidth + 2) === x)\r\n        .reverse();\r\n    }\r\n\r\n    this.setState({ verticalTileMap: tileMap });\r\n  }\r\n\r\n  renderVerticalMap() {\r\n    const tileMap = [];\r\n\r\n    if (typeof this.state.verticalTileMap === \"undefined\") {\r\n      return;\r\n    }\r\n\r\n    for (let x = 0; x < this.state.verticalTileMap.length; x++) {\r\n      tileMap[x] = (\r\n        <div key={\"board-vert-row\" + x}>\r\n          {this.state.verticalTileMap[x].map((i) => this.renderTile(i))}\r\n        </div>\r\n      );\r\n    }\r\n\r\n    return tileMap;\r\n  }\r\n\r\n  renderTile(tileobj) {\r\n    return (\r\n      <>\r\n        <Tile\r\n          tile={tileobj.char}\r\n          key={tileobj.id}\r\n          glyph={!this.state.useEmoji}\r\n          selected={tileobj.id === this.state.selectedTile}\r\n          hinted={\r\n            this.state.hintedTiles.includes(tileobj) && !tileobj.inRemovalAnim\r\n          }\r\n          highlighted={this.state.allValidMatchTiles.includes(tileobj.id)}\r\n          fade={tileobj.inRemovalAnim}\r\n          onClick={() => this.handleTileClick(tileobj.id)}\r\n        />\r\n        <PathNode\r\n          key={\"node\" + tileobj.id}\r\n          node={this.state.pathingTiles[tileobj.id]}\r\n        />\r\n        <PathNode\r\n          key={\"altnode\" + tileobj.id}\r\n          node={this.state.pathingTilesAlt[tileobj.id]}\r\n        />\r\n      </>\r\n    );\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <>\r\n        <div>\r\n          <div\r\n            className={`game-board game-board-horizontal ${\r\n              this.state.useEmoji ? \"game-board-emoji\" : \"game-board-glyph\"\r\n            }`}\r\n          >\r\n            {this.renderHorizontalMap()}\r\n          </div>\r\n          <div\r\n            className={`game-board game-board-vertical ${\r\n              this.state.useEmoji ? \"game-board-emoji\" : \"game-board-glyph\"\r\n            }`}\r\n          >\r\n            {this.renderVerticalMap()}\r\n          </div>\r\n          <div>\r\n            <button\r\n              onClick={() =>\r\n                this.setState((state) => ({ useEmoji: !state.useEmoji }))\r\n              }\r\n            >\r\n              Change tile type\r\n            </button>\r\n            <button onClick={() => this.generateBoard(this.state.seed)}>\r\n              Reset board\r\n            </button>\r\n            <button\r\n              onClick={() => this.undoMatch()}\r\n              disabled={this.state.tileHistory.length === 0}\r\n            >\r\n              Undo\r\n            </button>\r\n          </div>\r\n          <div>\r\n            <button onClick={() => this.generateBoard(null, 8, 5)}>\r\n              New board (easy)\r\n            </button>\r\n            <button onClick={() => this.generateBoard(null, 12, 7)}>\r\n              New board (medium)\r\n            </button>\r\n            <button onClick={() => this.generateBoard(null, 17, 8)}>\r\n              New board (hard)\r\n            </button>\r\n          </div>\r\n          <div>Board #{this.state.seed}</div>\r\n        </div>\r\n      </>\r\n    );\r\n  }\r\n}\r\n","import './App.css';\n\nimport Game from './game/Game.js'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Game/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}